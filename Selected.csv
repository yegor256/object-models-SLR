authors,title,abstract,keywords_detected,model_comments,model,general_comment
"Drossopoulou S,Noble J,Miller MS,Murray T",Permission and Authority Revisited towards a Formalisation,"Miller's notions of permissions and authority are foundational to the analysis of object-capability programming. Informal definitions of these concepts were given in Miller's thesis. In this paper we propose precise definitions for permissions and authority, based on a small object-oriented calculus. We quantify their bounds (current, eventual, behavioural, topological), and delineate the relationships between these definitions.","Object-Capabilities, Permission, Authority",permission based model,?,
"Chin WN,David C,Nguyen HH,Qin S",Enhancing Modular OO Verification with Separation Logic,"Conventional specifications for object-oriented (OO) programs must adhere to behavioral subtyping in support of class inheritance and method overriding. However, this requirement inherently weakens the specifications of overridden methods in superclasses, leading to imprecision during program reasoning. To address this, we advocate a fresh approach to OO verification that focuses on the distinction and relation between specifications that cater to calls with static dispatching from those for calls with dynamic dispatching. We formulate a novel specification subsumption that can avoid code re-verification, where possible. Using a predicate mechanism, we propose a flexible scheme for supporting class invariant and lossless casting. Our aim is to lay the foundation for a practical verification system that is precise, concise and modular for sequential OO programs. We exploit the separation logic formalism to achieve this.","automated verification, lossless casting, static and dynamic specifications, enhanced subsumption, separation logic",separation logic based,?,
K. J. Lieberherr; C. Xiao,Object-oriented software evolution,"The authors review propagation patterns for describing object-oriented software at a higher level of abstraction than one used by today's programming languages. A propagation pattern defines a family of programs from which one can select a member by giving a class dictionary graph that details the structure of behavior through part-of and inheritance relationships between classes. Three concepts are introduced: evolution histories, growth-plans and a propagation-directive calculus. Evolution histories describe a sequence of development phases of an object-oriented program, each phase being executable and therefore testable. To keep the programs flexible and short, they are described in terms of propagation patterns. Each phase of an evolution history is tested in small steps that are constrained by class dictionary graphs belonging to a growth-plan. Propagation directives are useful for describing both propagation patterns and growth-plans and are therefore endowed with sufficient expressiveness by being given a formal calculus applicable to object-oriented programming in general. A propagation directive is a succinct description of a family of submodels for a given family of data models.<<ETX>></ETX>",,,?,
Y. S. Kuo,When to inherit and when not to,"In object-oriented software development, it is generally accepted that inheritance should be used just to model a generalization/specialization relationship (i.e. an IS-A relation). This analysis/design guideline is too permissive. Some researchers thus advocate that a subclass should inherit the full a behavior of its superclass. Behavior inheritance, however, is far too restricted. In this paper, we establish a formal model that can clearly differentiate IS-A from behavior inheritance. Under this model, IS-A and behavior inheritance can be decomposed into more fundamental concepts: subsets and abstraction/concretization. Also, we are able to develop a set of refined guidelines regarding the use of inheritance.<<ETX>></ETX>",,,?,no source
Bruce KB,Some Challenging Typing Issues in Object-Oriented Languages: Extended Abstract,In this paper we discuss some of the remaining problems in the design of static type systems for object-oriented programming languages. We look at typing problems involved in writing a simple interpreter as a good example of a simple problem leading to difficult typing issues. The difficulties encountered seem to arise in situations where a programmer desires to simultaneously refine mutually interdependent classes and object types.,,,?,approach to a problem more than a model
"Giannini P,Richter T,Servetto M,Zucca E",Tracing sharing in an imperative pure calculus,"We introduce a type and effect system, for an imperative object calculus, which infers sharing possibly introduced by the evaluation of an expression, represented as an equivalence relation among its free variables. This direct representation of sharing effects at the syntactic level allows us to express in a natural way, and to generalize, widely-used notions in literature, notably uniqueness and borrowing. Moreover, the calculus is pure in the sense that reduction is defined on language terms only, since they directly encode store. The advantage of this non-standard execution model with respect to a behaviorally equivalent standard model using a global auxiliary structure is that reachability relations among references are partly encoded by scoping.","Imperative calculi, Sharing, Type and effect systems",,a imperative pure calculus,
"Abadi M,Cardelli L",A Theory of Primitive Objects: Untyped and First-Order Systems,"We introduce simple object calculi that support method override and object subsumption. We give an untyped calculus, typing rules, and equational rules. We illustrate the expressiveness of our calculi and the pitfalls that we avoid.",,,Abadi/Cardelli,
M. Abadi; L. Cardelli,A semantics of object types,"We give a semantics for a typed object calculus, an extension of System F with object subsumption and method override. We interpret the calculus in a per model, proving the soundness of both typing and equational rules. This semantics suggests a syntactic translation from our calculus into a simpler calculus with neither subtyping nor objects.<<ETX>></ETX>",,,Abadi/Cardelli,
Palsberg J,Efficient Inference of Object Types,"M. Abadi and L. Cardelli have recently investigated a calculus of objects (1994). The calculus supports a key feature of object-oriented languages: an object can be emulated by another object that has more refined methods. Abadi and Cardelli presented four first-order type systems for the calculus. The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. Open until now is the question of type inference, and in the presence of subtyping \the absence of minimum typings poses practical problems for type inference.\"" In this paper","we give an O(n3) algorithm for each of the four type inference problems and we prove that all the problems are P-complete. We also indicate how to modify the algorithms to handle functions and records.""",,Abadi/Cardelli based,
Dami L,"Operational Subsumption, an Ideal Model of Subtyping","In a previous paper we have defined a semantic preorder called operational subsumption, which compares terms according to their error generation behaviour. Here we apply this abstract framework to a concrete language, namely the Abadi-Cardelli object calculus. Unlike most semantic studies of objects, which deal with typed equalities and therefore require explicitly typed languages, we start here from a untyped world. Type inference is introduced in a second step, together with an ideal model of types and subtyping. We show how this approach flexibly accommodates for several variants, and finally propose a novel semantic interpretation of structural subtyping as embedding-projection pairs.",,,Abadi/Cardelli based,
J. Palsberg,Efficient inference of object types,"Abadi and Cardelli (1994) have investigated a calculus of objects. The calculus supports a key feature of object-oriented languages: an object can be emulated by another object that has more refined methods. Abadi and Cardelli presented four first-order type systems for the calculus. The simplest one is based on finite types and no subtyping, and the most powerful one has both recursive types and subtyping. Open until now is the question of type inference, and in the presence of subtyping ""the absence of minimum typings poses practical problems for type inference"". In this paper we give an O(n/sup 3/) algorithm for each of the four type inference problems and we prove that all the problems are P-complete.<<ETX>></ETX>",,,Abadi/Cardelli based,
D. Gopalani; M. C. Govil,Untyped Aspect Calculus : Formal theory of aspect-oriented programming languages,"The Object Calculi proposed by Abadi and Cardelli, treat objects as primitive constructs and define operations on these objects directly. This approach used by the object calculi overcomes the problem of complex encoding of objects as functions. The object calculi do not provide the direct support for aspects and its related concepts. We propose a calculus which provides direct support for aspects and other construct of Aspect-oriented programming paradigm. Our proposed calculus is an extension to the Untyped Imperative Object Calculus which is a part of the family of object calculi. We have worked upon the syntax and operational semantics of the proposed Untyped Aspect Calculus. The paper discusses the syntax and operational semantics of the calculus. Interpreter for the calculus is also designed and implemented and the same is discussed in the paper.",,,Abadi/Cardelli based,
V. Breazu-Tannen; T. Coquand; C. A. Gunter; A. Scedrov,Inheritance and explicit coercion,"A method is presented for providing semantic interpretations for languages which feature inheritance in the framework of statically checked, rich type disciplines. The approach is illustrated by an extension of the language Fun of L. Cardelli and P. Wegner (1985), which is interpreted via a translation into an extended polymorphic lambda calculus. The approach interprets inheritances in Fun as coercion functions already definable in the target of the translation. Existing techniques in the theory of semantic domains can then be used to interpret the extended polymorphic lambda calculus, thus providing many models for the original language. The method allows the simultaneous modeling of parametric polymorphism, recursive types, and inheritance, which has been regarded as problematic because of the seemingly contradictory characteristics of inheritance and type recursion on higher types. The main difficulty in providing interpretations for explicit type disciplines featuring inheritance is identified. Since interpretations follow the type-checking derivations, coherence theorems are required, and the authors prove them for their semantic method.<<ETX>></ETX>",,,Abadi/Cardelli based,
"Riecke JG,Stone CA",Privacy via Subsumption,"We describe an object calculus allowing object extension and structural subtyping. Each object has a “dictionary” to mediate the connection between names and components. This extra indirection yields the first object calculus combining both object extension and full width subtyping in a type-safe manner. If class inheritance is modeled with object extension, private fields and methods can be achieved directly by scoping restrictions: private fields or methods are those hidden by subsumption. We prove that the type system is sound, discuss a variant allowing covariant self types, and give some examples of the expressiveness of the calculus.",,,Abadi/Cardelli based,
B. Reus; T. Streicher,Semantics and logic of object calculi,The main contribution of this paper is a formal characterization of recursive object specifications based on a denotational untyped semantics of the object calculus and the discussion of existence of those (recursive) specifications. The semantics is then applied to prove soundness of a programming logic for the object calculus and to suggest possible extensions. For the purposes of this discussion we use an informal logic of predomains in order to avoid any commitment to a particular syntax of specification logic.,,,"Abadi/cardelli based
Abadi/Leino logic based",
"Kleist J,Sangiorgi D",Imperative objects as mobile processes,"An interpretation of Abadi and Cardelli's first-order Imperative ς-calculus into a typed π-calculus is presented. The interpretation validates the subtyping relation and the typing judgments of the ς-calculus, and is computationally adequate. The proof of computational adequacy makes use of (a π-calculus version) of ready simulation, and of a factorization of the interpretation into a functional part and a very simple imperative part. The interpretation can be extended to accommodate various type features. The interpretation can be used to compare and contrast the Imperative and the Functional ς-calculus, and to prove properties about them, within a unified framework.",,,"Abadi/Cardelli based
pi calculus based",
"Bugliesi M,Pericás-Geertsen SM",Type Inference for Variant Object Types,"Existing type systems for object calculi are based on invariant subtyping. Subtyping invariance is required for soundness of static typing in the presence of method overrides, but it is often in the way of the expressive power of the type system. Flexibility of static typing can be recovered in different ways: in first-order systems by the adoption of object types with variance annotations, in second-order systems by resorting to Self types. Type inference is known to be P-complete for first-order systems of finite and recursive object types, and NP-complete for a restricted version of Self types. The complexity of type inference for systems with variance annotations is yet unknown. This paper presents a new object type system based on the notion of Split types, a form of object types where every method is assigned two types, namely, an update type and a select type. The subtyping relation that arises for Split types is variant and, as a result, subtyping can be performed both in width and in depth. The new type system generalizes all the existing first-order type systems for objects, including systems based on variance annotations. Interestingly, the additional expressive power does not affect the complexity of the type inference problem, as we show by presenting an O(n3) inference algorithm.",,"calculus
type inference
ivariance subtyping
variance anotations 
self types
split types","Abadi/Cardelli based
sigma calculus",
"Reus B,Streicher T",Semantics and logic of object calculi,"The main contribution of this paper is a formal characterization of recursive object specifications and their existence based on a denotational untyped semantics of the object calculus. Existence is not guaranteed but can be shown employing Pitts’ results on relational properties of domains. The semantics can be used to analyse and verify Abadi and Leino's object logic but it also suggests extensions. For example, specifications of methods may not only refer to fields but also to methods of objects in the store. This can be achieved without compromising the existence theorem. An informal logic of predomains is in use intentionally in order to avoid any commitment to a particular syntax of specification logic.","Object logic, Programming logic, Program verification, Denotational semantics, Domain theory","object calculi,
object type system,
recursive object specification","Abadi/Cardelli based
sigma calculus based
Abadi/Leino logic based",
N. Hoshino,Step Indexed Realizability Semantics for a Call-by-Value Language Based on Basic Combinatorial Objects,"We propose a mathematical framework for step indexed realizability semantics of a call-by-value polymorphic lambda calculus with recursion, existential types and recursive types. Our framework subsumes step indexed realizability semantics by untyped call-by-value lambda calculi as well as categorical abstract machines. Starting from an extension of Hofstra's basic combinatorial objects, we construct a step indexed categorical realizability semantics. Our main result is soundness and adequacy of our step indexed realizability semantics. As an application, we show that a small step operational semantics captures the big step operational semantics of the call-by-value polymorphic lambda calculus. We also give a safe implementation of the call-by-value polymorphic lambda calculus into a categorical abstract machine.",Semantics of Programming Languages;operational semantics;denotational semantics,,"abstract machine based
lmbda calculus based",
"Ernst GW,Hookway RJ,Menegay JA,Ogden WF",Modular verification of Ada generics,"This paper develops modular verification rules for Ada generics which are proven to be sound and complete. The generic mechanism in Ada allows modules to be parameterized by types, procedures and functions. The modularity property allows a generic to be verified once, and then exported to other modules which assume that it is correct. This requires the generic to have a specification which is used in verifying other modules, but its implementation cannot be used for this purpose. Thus, modular verification cannot be based on removing generics by macro expansion which requires the use of the generic's implementation. The main difficulty with specifying and verifying a generic is that the specification language may need to be extended with a new theory for specifying and reasoning about properties of objects whose type is a parameter to the generic. Such theories must be part of the specification of the generic, and this raises the possibility that the extended specification language may not be expressive, even if it was before the extension. The use of strings in our specification language prevents this from happening, which is proven in the paper; this is a major step toward establishing the completeness of our rules. Modularity also had a large impact on our semantics for programming constructs which is quite different from the usual semantics in the literature, even though it is still based the denotational semantics of Scott and Strachey. The main reason for this is that we had to modify the standard definition of validity. Modularity requires that validity depend on certain internal assertions in a program, such as the precondition of a procedure invoked in the program.","Verification, Program correctness, Ada generics, Formal specification, Program semantics, Logical soundness, Program validity",,Ada's model,
A. Bader; T. Elrad,The Adaptive Arena: language constructs and architectural abstractions for concurrent object-oriented systems,"In this paper we present a concurrent object-oriented model in which a concurrent object, which represents a shared resource abstraction in our model, is decomposed into a hierarchy of architectural abstractions: a shared data abstraction, a synchronization abstraction, and a scheduling abstraction. It will be shown that the separation of concerns among the three major components of the concurrent objects avoids many of the conceptual difficulties that arise when integrating concurrency into the object-oriented paradigm. The proposed model presents a formal methodology for the architectural design and specification of the concurrent object-oriented software systems. The notion of scheduling policy inheritance in our model facilitates the process of engineering adaptability in the development of the intelligent reactive/adaptive systems.",,,Adaptive Arena model,
"Kogtenkov A,Meyer B,Velder S","Alias calculus, change calculus and frame inference","Alias analysis, which determines whether two expressions in a program may reference to the same object, has many potential applications in program construction and verification. We have developed a theory for alias analysis, the “alias calculus”, implemented its application to an object-oriented language, and integrated the result into a modern IDE. The calculus has a higher level of precision than many existing alias analysis techniques. One of the principal applications is to allow automatic change analysis, which leads to inferring “modifies” clauses, providing a significant advance towards addressing the Frame Problem. Experiments were able to infer the “modifies” clauses of an existing formally specified library. Other applications, in particular to concurrent programming, also appear possible. The article presents the calculus, the application to frame inference including experimental results, and other projected applications. The ongoing work includes building more efficient model capturing aliasing properties and soundness proof for its essential elements.","Verification, Alias analysis, Frame inference, Object-oriented, Static analysis",,Alias calculus,
"Gheyi R,Massoni T,Borba P",A Static Semantics for Alloy and its Impact in Refactorings,"Refactorings are usually proposed in an ad hoc way because it is difficult to prove that they are sound with respect to a formal semantics, not guaranteeing the absence of type errors or semantic changes. Consequently, developers using refactoring tools must rely on compilation and tests to ensure type-correctness and semantics preservation, respectively, which may not be satisfactory to critical software development. In this paper, we formalize a static semantics for Alloy, which is a formal object-oriented modeling language, and encode it in Prototype Verification System (PVS). The static semantics' formalization can be useful for specifying and proving that transformations in general (not only refactorings) do not introduce type errors, for instance, as we show here.","refactoring, type system, theorem proving, object models",,Alloy ,
"Giannini P,Servetto M,Zucca E,Cone J",Flexible recovery of uniqueness and immutability,"We present an imperative object calculus where types are annotated with qualifiers for aliasing and mutation control. There are two key novelties with respect to similar proposals. First, the type system is very expressive. Notably, it adopts the recovery approach, that is, using the type context to justify strengthening types, greatly improving its power by permitting to recover uniqueness and immutability properties even in presence of other references. This is achieved by rules which restrict the use of such other references in the portion of code which is recovered. Second, execution is modeled by a non standard operational model, where properties of qualifiers can be directly expressed on source terms, rather than as invariants on an auxiliary structure which mimics physical memory. Formally, this is achieved by the block construct, introducing local variable declarations, which, when evaluated, play the role of store.","Type systems, Imperative calculi, Immutability, Aliasing",,"an imperative pure calculus
Featherweight based
Gianini/Servetto/Zucca/Cone calculus",
"Giannini P,Servetto M,Zucca E",Tracing Sharing in an Imperative Pure Calculus: Extended Abstract,"We introduce a type and effect system, for an imperative object calculus, which infers sharing possibly introduced by the evaluation of an expression. Sharing is directly represented at the syntactic level as a relation among free variables, thanks to the fact that the calculus is pure. That is, imperative features are modeled by just rewriting source code terms. We consider both standard variables and affine variables, which can occur at most once in their scope. The latter are used as temporary references, to \move\"" a capsule (an isolated portion of store) to another location in the store. The sharing effects inferred by the type system are very expressive","and generalize notions introduced in literature by type modifiers.""",,"an imperative pure calculus
Gianini/Servetto/Zucca calculus",
M. Ancona,Inheritance and subtyping (object-oriented databases),"A method for implementing subtyping and inheritance, as independent features of object-oriented languages, is presented. There are at least two reasons for decoupling subtyping from inheritance: the negative influence on encapsulation and the different perspective of specification inheritance (subtyping) and implementation inheritance (code sharing). Subtyping and inheritance are defined in two independent constructs: the class module and the implementation module which are separately compiled. Subtyping is declared in the class module which contains all the public definitions of the class (e.g., types ad operation signatures), while inheritance is defined in the implementation module, which contains the implementations of all the operations of the class. The class module includes assertions which are an algorithmic form of operation specification.<<ETX>></ETX>",,"inheritance
subtyping",Ancona's model,
"Ancona D,Corradi A",Semantic Subtyping for Imperative Object-Oriented Languages,"Semantic subtyping is an approach for defining sound and complete procedures to decide subtyping for expressive types, including union and intersection types; although it has been exploited especially in functional languages for XML based programming, recently it has been partially investigated in the context of object-oriented languages, and a sound and complete subtyping algorithm has been proposed for record types, but restricted to immutable fields, with union and recursive types interpreted coinductively to support cyclic objects. In this work we address the problem of studying semantic subtyping for imperative object-oriented languages, where fields can be mutable; in particular, we add read/write field annotations to record types, and, besides union, we consider intersection types as well, while maintaining coinductive interpretation of recursive types. In this way, we get a richer notion of type with a flexible subtyping relation, able to express a variety of type invariants useful for enforcing static guarantees for mutable objects. The addition of these features radically changes the defi- nition of subtyping, and, hence, the corresponding decision procedure, and surprisingly invalidates some subtyping laws that hold in the functional setting. We propose an intuitive model where mutable record val- ues contain type information to specify the values that can be correctly stored in fields. Such a model, and the correspond- ing subtyping rules, require particular care to avoid circularity between coinductive judgments and their negations which, by duality, have to be interpreted inductively. A sound and complete subtyping algorithm is provided, together with a prototype implementation.","Structural Types for Objects, Semantic Subtyp- ing, Read/Write Field Annotations",,Ancona/Corradi model,
"Ancona D,Lagorio G",Complete Coinductive Subtyping for Abstract Compilation of Object-Oriented Languages,"Coinductive abstract compilation is a novel technique, which has been recently introduced, for defining precise type systems for object-oriented languages. In this approach, type inference consists in translating the program to be analyzed into a Horn formula f, and in resolving a certain goal w.r.t. the coinductive (that is, the greatest) Herbrand model of f.Type systems defined in this way are idealized, since types and, consequently, goal derivations, are not finitely representable. Hence, sound implementable approximations have to rely on the notions of regular types and derivations, and of subtyping and subsumption between types and atoms, respectively.In this paper we address the problem of defining a complete subtyping relation ≤ between types built on object and union type constructors: we interpret types as sets of values, and investigate on a definition of subtyping such that t1 ≤ t2 is derivable whenever the interpretation of t1 is contained in the interpretation of t2. Besides being an important theoretical result, completeness is useful for reasoning about possible implementations of the subtyping relation, when restricted to regular types.","coinduction, Java, subtyping, union types, type inference",,Ancona/Lagorio model,
"Hainry E,Péchoux R",A type-based complexity analysis of Object Oriented programs,"A type system is introduced for a generic Object Oriented programming language in order to infer resource upper bounds. A sound and complete characterization of the set of polynomial time computable functions is obtained. As a consequence, the heap-space and the stack-space requirements of typed programs are also bounded polynomially. This type system is inspired by previous works on Implicit Computational Complexity, using tiering and non-interference techniques. The presented methodology has several advantages. First, it provides explicit big O polynomial upper bounds to the programmer, hence its use could allow the programmer to avoid memory errors. Second, type checking is decidable in polynomial time. Last, it has a good expressivity since it analyzes most object oriented features like inheritance, overload, override and recursion. Moreover it can deal with loops guarded by objects and can also be extended to statements that alter the control flow like break or return.","Object Oriented Program, Type system, Complexity, Polynomial time",,AOO PL,
"Apt KR,de Boer FS,Olderog ER,de Gouw S",Verification of object-oriented programs: A transformational approach,"We show that verification of object-oriented programs by means of the assertional method can be achieved in a simple way by exploiting a syntax-directed transformation from object-oriented programs to recursive programs. This transformation suggests natural proofs rules and its correctness helps us to establish soundness and relative completeness of the proposed proof system. One of the difficulties is how to properly deal in the assertion language with the instance variables and aliasing. The discussed programming language supports arrays, instance variables, failures and recursive methods with parameters. We also explain how the transformational approach can be extended to deal with other features of object-oriented programming, like classes, inheritance, subtyping and dynamic binding.","Object-oriented programs, Null references, Aliasing, Inheritance, Subtyping, Syntax-directed transformation, Recursive programs, Program verification, Strong partial correctness, Relative completeness",,Apt/Boer/Olderog/Gouw/ model,
R. Guetari; A. Haurat,"Algebraic specification of abstract data type and transition graphs: formal techniques for object-oriented analysis, specification and design","A transition graph is a formal tool dedicated to the specification of communicant processes. However, we show that it is a useful way to analyse and specify the behaviour of objects of the real world in order to model them in the form of classes. This paper presents the transition graphs theory. The class model features and establishes the relationship between these two concepts. Then we show how to describe and model an entity of the real world with a transition graph and the techniques allowing us to automatically generate a corresponding class. This study has allowed us to develop a graphic software tool which, from a transition graph, enables us to generate an algebraic specification and a class.",,,ASAT,
R. Guetari; A. Haurat,Object-oriented specification and design using the transition graphs,"A transition graph is a formal tool dedicated to the specification of communicant processes. However, we show that it is a useful way to analyse and specify the behaviour of objects of the real world in order to model them in the form of classes. The paper presents the transition graph theory, the class model features and establishes the relationship between these two concepts. Then we show how to describe and model an entity of the real world with a transition graph and the techniques allowing us to automatically generate a corresponding class. This study has allowed us to develop a graphic software tool which, from a transition graph, enables us to generate an algebraic specification and a class.",,,ASAT,
"Pierik C,de Boer FS",A proof outline logic for object-oriented programming,This paper describes a proof outline logic that covers most typical object-oriented language constructs in the presence of inheritance and subtyping. The logic is based on a weakest precondition calculus for assignments and object allocation which takes field shadowing into account. Dynamically bound method calls are tackled with a variant of Hoare's rule of adaptation that deals with the dynamic allocation of objects in object-oriented programs. The logic is based on an assertion language that is closely tailored to the abstraction level of the programming language.,"Proof outline logic, Hoare logic, Object-oriented programming, Verification, Rule of adaptation",,"AsO
asserion language
proof outline logic based",
"Henrio L,Kammüller F,Lutz B",ASPfun : A typed functional active object calculus,"This paper provides a sound foundation for autonomous objects communicating by remote method invocations and futures. As a distributed extension of ς-calculus we define ASPfun, a calculus of functional objects, behaving autonomously and communicating by a request-reply mechanism: requests are method calls handled asynchronously and futures represent awaited results for requests. This results in an object language enabling a concise representation of a set of active objects interacting by asynchronous method invocations. This paper first presents the ASPfun calculus and its semantics. Then, we provide a type system for ASPfun which guarantees the “progress” property. Most importantly, ASPfun has been formalised; its properties have been formalised and proved using the Isabelle theorem prover and we consider this as an important step in the formalization of distributed languages. This work was also an opportunity to study different binder representations and experiment with two of them in the Isabelle/HOL theorem prover.","Theorem proving, Object calculus, Futures, Distribution, Typing, Binders",,"AspFun
Abadi/Cardelli based",
R. C. M. de Rooij; J. van Katwijk,An approach towards formal verification of object oriented real-time systems,"This paper describes an approach towards verification of object oriented real-time software systems, based on ATL+, a formal specification language of which the syntax and semantics are inspired by the Java programming language. Using a specification language based on an object oriented programming language reduces the semantic gap between the implementation of a system and the model used for verification. We describe the syntax and semantics of ATL+, as well as a transformation procedure by which ATL+ is transformed into a notation suitable for use with an automated verification tool. We show the applicability of our method by giving some verification results, in which properties and constraints on design parameters are derived for a simple example.",,,ATL+,"real time, verification"
B. H. C. Cheng; G. C. Gannod,Abstraction of formal specifications from program code,"A description is presented of the development of the tool AUTOSPEC (automated specification), which abstracts formal specifications from program code. The abstraction process can incorporate domain-specific information supplied interactively by the user, as necessary. The abstraction algorithms and a discussion of the use of formal methods and object-oriented techniques for the development of AUTOSPEC are given. Implementation-specific information is given and related work is described.<<ETX>></ETX>",,,AutoSpec,
Conrad S,A basic calculus for verifying properties of interacting objects,"We introduce a basic calculus for expressing and proving properties of interacting objects. The objects considered have dynamic behaviour and are organized into object communities in a hierarchical way. After a detailed and formal presentation of the calculus, essential properties of the calculus are discussed, especially the question of compositionality. The calculus constitutes a basis for investigating issues of verifying properties of objects and object communities. In consequence, we have focused on a small number of essential concepts. This calculus can be seen as an extensible basis applicable to different object-oriented specification frameworks.","Object specification, Dynamic objects, Verification, Compositional specification, Compositional verification, Basic calculus",,basic calculus,
"Binder D,Jabs J,Skupin I,Ostermann K",Decomposition Diversity with Symmetric Data and Codata,"The expression problem describes a fundamental trade-off in program design: Should a program's primary decomposition be determined by the way its domain objects are constructed (""functional"" decomposition), or by the way they are destructed (""object-oriented"" decomposition)? We argue that programming languages should not force one of these decompositions on the programmer; rather, a programming language should support both ways of decomposing a program in a symmetric way, with an easy translation between these decompositions. However, current programming languages are usually not symmetric and hence make it unnecessarily hard to switch the decomposition. We propose a language that is symmetric in this regard and allows a fully automatic translation between ""functional"" and ""object-oriented"" decomposition. We present a language with algebraic data types and pattern matching for ""functional"" decomposition and codata types and copattern matching for ""object-oriented"" decomposition, together with a bijective translation that turns a data type into a codata type (""destructorization"") or vice versa (""constructorization""). We present the first symmetric programming language with support for local (co)pattern matching, which includes local anonymous function or object definitions, that allows an automatic translation as described above. We also present the first mechanical formalization of such a language and prove i) that the type system is sound, that the translations between data and codata types are ii) type-preserving, iii) behavior-preserving and iv) inverses of each other. We also extract a mechanically verified implementation from our formalization and have implemented an IDE with direct support for these translations.",,,Binder/Jabs/Skupin/Ostermann PL,
"Given-Wilson T,Huang F,Jay B",Multi-Polymorphic Programming in Bondi,"The bondi programming language is multi-polymorphic, in that it supports four polymorphic programming styles within a small core of computation, namely a typed pattern calculus. bondi's expressive power is illustrated by considering the problem of assigning reviewers to a paper. As the context generalises from a committee to a committee with additional reviewers, to a conference, to a federation or confederation, the solution incorporates polymorphism familiar from the functional, generic functional, relational, path-based, and object-oriented programming styles, respectively. These experiments show that multi-polymorphic programming is both practical and desirable.","polymorphism, pattern matching, pattern calculus, generic programming, bondi",,Bondi PL,
"Bono V,Patel A,Shmatikov V,Mitchell J",A Core Calculus of Classes and Objects,"We present an imperative calculus for a class-based language. By introducing classes as the basic object-oriented construct in a λ-calculus with records and references, we obtain a system with an intuitive operational semantics. Objects are instantiated from classes and represented by records. The type system for objects uses only functional, record, and reference types, and there is a clean separation between subtyping and inheritance. We demonstrate that the calculus is sound and sufficiently expressive to model advanced language features such as inheritance with method redefinition, multi-level encapsulation, and modular object construction.","object-oriented language, class, calculus, operational semantics, type system.",,"Bono/Pate/Shmatnikov/Mitchell calculus
Wright based",ref: Wright and M. Felleisen. A Syntactic Approach to Type Soundness
Bonniot D,Using kinds to type partially-polymorphic methods,"We extend type constraints with kind constraints to increase the expressiveness of constraint-based nominal type systems. In the context of object-oriented programming languages, they offer an alternative to the use of F-bounded polymorphism to type homogeneous binary methods. We also introduce the notion of partially polymorphic methods to describe a common situation in object-oriented hierarchies, and show how these can be typed in a modular fashion with kind constraints.",,,Booniot type model,
"Borba P,Sampaio A,Cavalcanti A,Cornélio M",Algebraic reasoning for object-oriented programming,"We present algebraic laws for a language similar to a subset of sequential Java that includes inheritance, recursive classes, dynamic binding, access control, type tests and casts, assignment, but no sharing. These laws are proved sound with respect to a weakest precondition semantics. We also show that they are complete in the sense that they are sufficient to reduce an arbitrary program to a normal form substantially close to an imperative program; the remaining object-oriented constructs could be further eliminated if our language had recursive records. This suggests that our laws are expressive enough to formally derive behaviour preserving program transformations; we illustrate that through the derivation of provably-correct refactorings.",,"weakest precondition semantics
refinemet calculus",Borba/Sampaio/Cavalcanti/Cornellio mode;,"ref:
A. L. C. Cavalcanti and D. A. Naumann. A Weakest Precondition Semantics for Refinement of Ob ject-oriented Programs. IEEE Transactions on Software Engineering, 26(8):713 – 728, 2000.

P. H. M. Borba, A. C. A. Sampaio, and M. L. Corn ́elio. A Refinement Algebra for Object-oriented Programming. In Luca Cardelli, editor, European Conference on Object-oriented Programming 2003 — ECOOP 2003, volume 2743 of Lecture Notes in Computer Science, pages 457 – 482. Springer-Verlag, 2003."
"Burton E,Sekerinski E",The Safety of Dynamic Mixin Composition,"Dynamic mixins are a modular means of developing features or roles that can be composed with objects at run-time. However, naive use of this construct can cause unexpected behaviour due to interference caused by the presence of an object's previously bound mixins. This work proposes a method for developing mixins that can be bound to base objects such that the mixins do not interfere with each other; the method achieves compositionally through a coupling invariant and by syntactically restricting mixins. The refinement calculus is used for formalization, as it treats implementations and specifications uniformly. The formalization relies on a new notion of mixin refinement.","refinement, mixins, compositionality, safety, modularity",,"Burton/Sekeriski model
mixins",
Eun-Sun Cho; Sang-Yong Han; Hyoung-Joo Kim,A semantics of the separation of interface and implementation in C++,"C++ uses 'class' as the basis of 'subtype polymorphism' and 'inheritance', but it has been pointed out that the overloading of 'class' limits the expressiveness and makes its type system inflexible. This means that C++ and some other object oriented languages had to separate a class into two modules-an interface and an implementation. But, there seems to be no leading C++ model for separating the interface lattice from the implementation lattice. Moreover none of the proposed models describe the result of the separation in a formal way. As a result it is hard to understand what the type space would be like after the separation. The paper presents a formal model for the separation of interface and implementation in C++, and which explains the properties of the resulting type space after the separation.",,separation of interface and implementation,"C++ based
separation of interface and implementation",
Knapp A,Chapter 5 - Generating Rewrite Theories from UML Collaborations,"Publisher Summary This chapter presents an executable model for collaborations and interactions of the Unified Modeling Language as a rewriting logic theory in CafeOBJ. The Unified Modeling Language comprises a notion of interaction modeling, called collaborations, and simultaneously features a sound abstract syntax and a rich and detailed, though informal, semantics for this concept. However, the transfer of known simulation results is limited by some semantical deviations and the integration of new characteristics. In an UML model, collaborations specify how an operation or a use case of the model is realized by a cooperation of several instances of model elements. Therefore this chapter proposes an executable formal model for UML collaborations that is directly based on UML's abstract syntax and provably correct with respect to the temporal logic semantics of interactions, thus yielding simulation capabilities for UML's specific notion of interaction modeling. The chapter uses rewriting logic dimension of the algebraic specification language CafeOBJ, as a semantic framework that allows for a unified treatment of object-orientation and concurrency. Moreover, it summarizes UML collaboration's concrete and abstract syntax and the formal semantics of UML interactions in temporal logic. This chapter also describes the generation of a CafeOBJ specification from UML collaboration along with the correctness proof for the generated rewrite theory with respect to the temporal logic specification of the collaboration's interaction. The chapter concludes conclude with an outlook to possible refinements and extensions.",,,CafeOBJ,
Kung-Kiu Lau; M. Omaghi; A. Wills,Frameworks in Catalysis: pictorial notation and formal semantics,"In OO Design, it is widely recognised that the distribution of tasks between objects and the contracts between them are key to effective design. In composing designs from reusable parts, the parts are therefore frameworks, namely descriptions of the interactive relationships between objects which participate in the interactions. Designs are then built by composing these frameworks, and any object in the final design will play (various) roles from several frameworks. Practitioners of OO Design use pictorial notations for design. However, in order to reason formally about design, we need a sound (formal) semantics for the diagrams. In this paper, we show that frameworks can be formalised as many-sorted theories, and then present a pictorial representation of such theories, developed in the Catalysis project.",,,Catalysis based,
F. Zeyda; L. Lalkhumsanga; A. Cavalcanti; A. Wellings,Circus Models for Safety-Critical Java Programs,"Safety-critical Java (SCJ) is a restriction of the real-time specification for Java to support the development and certification of safety-critical applications. The SCJ technology specification is the result of an international effort from industry and academia. In this paper, we present a formalization of the SCJ Level 1 execution model, formalize a translation strategy from SCJ into a refinement notation and describe a tool that largely automates the generation of the formal models. Our modelling language is part of the Circus family; at the core, we have Z, communicating sequential processes and Morgan's calculus, but we also use object-oriented and timed constructs from the OhCircus and Circus Time variants. Our work is an essential ingredient for the development of refinement-based reasoning techniques for SCJ.",Circus;real-time systems;formal models;translation;refinement;RTSJ,Circus,Circus Model,
"Balzer S,Pfenning F",Objects as Session-Typed Processes,"A key idea in object-oriented programming is that objects encapsulate state and interact with each other by message exchange. This perspective suggests a model of computation that is inherently concurrent (to facilitate simultaneous message exchange) and that accounts for the effect of message exchange on an object's state (to express valid sequences of state transitions). In this paper we show that such a model of computation arises naturally from session-based communication. We introduce an object-oriented programming language that has processes as its only objects and employs linear session types to express the protocols of message exchange and to reason about concurrency and state. Based on various examples we show that our language supports the typical patterns of object-oriented programming (e.g., encapsulation, dynamic dispatch, and subtyping) while guaranteeing session fidelity in a concurrent setting. In addition, we show that our language facilitates new forms of expression (e.g., type-directed reuse, internal choice), which are not available in current object-oriented languages. We have implemented our language in a prototype compiler.","object, session types, protocol, linear types, process",,CLOO,
"Iglewski M,Müldner T",Comparison of formal specification methods and object-oriented paradigms,"Object orientation and formal methods are widely regarded as two fields with significant potential for new software engineering techniques. This paper discusses the relations between these two approaches. We present various specification techniques which incorporate object-oriented paradigms, discuss their place in software development process, and analyse possible benefits from their applications.",,,comparison,
K. Louzaoui; K. Benlhachmi; J. A. Chentoufi,Conformity testing by optimal constraints for object oriented programs,The objective of this paper is to introduce a new constraint model for testing the conformity of overriding methods during inheritance operation for an object oriented (OO) system. This model is based on formal specification techniques and can be used to generate test data in derived classes. The key idea of this conformity approach is to use an optimal constraint and a partitioning technique based on a mathematical analysis to automate the conformity testing of overriding methods.,Specification;Conformity Testing;Robustness Testing;Valid Data;Invalid Data;Test Data Generation;Inheritance;Constraint Resolution,,constraint model,
"Köhler M,Eskandani N,Weisenburger P,Margara A,Salvaneschi G",Rethinking Safe Consistency in Distributed Object-Oriented Programming,"Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files. In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.","Java, replication, type systems, consistency",,ConSysT,
"Hirschfeld R,Igarashi A,Masuhara H",ContextFJ: A Minimal Core Calculus for Context-Oriented Programming,"We develop a minimal core calculus called ContextFJ to model language mechanisms for context-oriented programming (COP). Unlike other formal models of COP, ContextFJ has a direct operational semantics that can serve as a precise description of the core of COP languages. We also discuss a simple type system that helps to prevent undefined methods from being accessed via proceed.","context-oriented programming, operational semantics",,ContextFJ,
"Clarke D,Sergey I",A Semantics for Context-Oriented Programming with Layers,"Context-oriented programming (COP) is a new programming approach whereby the context in which expressions evaluate can be adapted as a program runs. COP provides a degree of flexibility beyond object-oriented programming, while arguably retaining more modularity and structure than aspect-oriented programming. Although many languages exploring the context-oriented approach exist, to our knowledge no formal type-sound dynamic semantics of these languages exists. We address this shortcoming by providing a concise syntax-based formal semantics for context-oriented programming with layers, as witnessed by ContextL, ContextJ*, and other languages. Our language is based on Featherweight Java extended with layers and scoped layer activation and deactivation. As layers may introduce methods not appearing in classes, we also give a static type system that ensures that no program gets stuck (i.e., there exists a binding for each dispatched method call).",,,"ContextJ based model
Featherweight based",
M. Benattou; L. Lakhal,Incremental inheritance mechanism and its message evaluation method,"The semantics of inheritance is based on subtyping. Several authors have shown that the subtype relation is insufficient to explain the inheritance mechanism in object oriented approach. Inheritance is an incremental mechanism for software development, based on modification. This approach was introduced by W.R. Cook. The aim of this paper is to present, an incremental formal model of single and multiple inheritance, based on the wrapping concept. The model is based upon an intuitive explanation of the proper use and purpose of inheritance, and is essentially dedicated to dynamic (i.e. run-time) inheritance of properties, for OODBMS. The denotational semantics method proposed using the incremental model of inheritance, allows dynamic message evaluation.",,inheritance,Cook's model based,"ref: W. R. Cook, J. Palsberg, ”A Denotational Semantics of Inheritance and its Correctness”."
B. Xu; B. Hua; Y. Gao,An imperative formal calculus for Java,"This paper presents a formal imperative calculus to formalize the semantics of class-based object-oriented programming languages. The tractability of this approach is demonstrated by our formalization of a core subset of the Java programming language called Cool: Core Object-Oriented Language. Cool is relatively small but retains many of modern class-based object-oriented languages' key features, including classes, inheritance, objects, virtual functions and dynamic method dispatch etc. The technical contribution of this paper can be summarized as: first, this paper formalizes a syntactic specification for Cool; second, this paper presents static semantics for Cool via typing rules, and its operational semantics via small-step transition relation. Finally, this paper proves that the formal calculus proposed is type safe.",programming languages;semantics;type system,COOL,COOL Model,
Wang Yunfeng; Li Bixin; Pang Jun; Zha Ming; Zheng Guoliang,A formal software development approach based on COOZ and refinement calculus,"Including refinement calculus into COOZ complements its disadvantage during design and implementation. The separation between design and implementation for construct and notation is removed as well. Then the software can be developed smoothly in the same frame. There is no corresponding object oriented construct in existing refinement calculus. The combination of COOZ and refinement calculus can build an object oriented frame in which the specification in COOZ is refined stepwise to code by calculus. Two development models are discussed which are based mainly on COOZ and the refinement calculus respectively. The first model is first discussed and then the data refinement and operation refinement is analyzed by example. The two methods of operation refinement for OO formal specification are outlined, and the frame transition rule from COOZ to C++ is examined.",,COOZ,COOZ Model,
Yuan Xiaodong; Hu Deqiang; Xu Hao; Li Yong; Zheng Guoliang,Complete Object-Oriented Z and its supporting environment COOZ-Tools,"The paper introduces the design of COOZ, which stands for ""Complete Object-Oriented Z"", and the system architecture, functions, characteristics and key techniques of its supporting environment COOZ-Tools. Compared with current Z object-oriented extensions COOZ clarifies some object-oriented notions, such as distinction between active object and passive object. It also provides a more clear form of specifications. For example, the authors separate pre-conditions of schema from its post-conditions explicitly, and give subtypes of an object type as well as its supertypes. COOZ is more powerful than other object-oriented Z notations when specifying real-time and concurrent systems by using duration calculus to describe real-time and history constraints of objects. It is also adapted to larger and complex software systems benefiting from is module mechanism. They have developed the integrated toolbox environment COOZ-Tools supporting COOZ language in a SGI workstation. COOZ-Tools is composed of the following five tools: specification editor and viewers, syntax and semantics checking tool. Refinement aided tool, on-line help system and project management tool.",,COOZ,COOZ Model,
S. Han,Verification of Java programs in Coq,"This paper is a research on functional interpretation of object-oriented programs in the intensional type theory with dependent record types and coercive subtyping. We are here simulating a type-theoretic model of Java programs in Coq. Representing a class and its interface-type, which declares a set of methods and their signatures for code reuse, as dependent record types, the type-theoretic encoding enjoys desirable subtyping relationships that correctly capture the important object-oriented features such as inheritance, subtype polymorphism and dynamic dispatch. Furthermore, since the model is given in the intensional type theory, machine-supported verification of Java programs can be done by proving specifications that is satisfied by Java programs in Coq with regard to the state of objects.",,Coq,Coq Prover,
"Gil de Lamadrid J,Zimmerman J",Core FOBS: A hybrid functional and object-oriented language,"We describe a computer language that is a hybrid between functional and object-oriented languages. The language is based on a simple structure called a FOB (functional-object), capable of being used as a function, or accessed as an object. FOBS is a dynamically typed, referentially transparent language, designed for use as a universal scripting language. An extensive library is integral to the language. The library implements the primitive types and provides an interface to the external environment, allowing scripting actions to be carried out. FOBS is structured as an extended language, that is reduced to a core language by macro expansion. Our paper provides an introduction to the core language, a brief discussion of the extended language, and formal specifications of syntax and semantics for the core. The formal semantic description for FOBS is somewhat unusual for a scripting language. However, this description ensures that the FOBS semantics is well-specified, allowing programmers to write well understood programs, increasing program reliability.","Object-oriented, Functional, Hybrid",,CoreFOBS,
"Blanchette JC,Owe O",An Open System Operational Semantics for an Object-Oriented and Component-Based Language,"Object orientation and component-based development have both proven useful for the elaboration of open distributed systems. These paradigms are offered by the Creol language. Creol objects are concurrent, each with its own virtual processor and internal process control, and communicate using asynchronous (non-blocking) method calls. This provides the efficiency of message passing systems, while keeping the structuring benefits of methods and object-oriented programming. Conditional processor release points provide a high-level synchronization mechanism based on passive waiting that allows us to combine active and reactive behavior. A Creol component can be a single (concurrent) object or a collection of objects, together with a number of interfaces, and cointerfaces, defining the provided and required interaction and semantic behavior. Creol's semantics is defined formally using operational semantics and Hoare logic. An operational semantics lets us simulate an entire system, where all components are known in advance; in contrast, Hoare logic, together with class invariants and communication histories, lets us reason locally about a method body, without needing access to the implementations of the other classes. To bridge the gap between these two semantics, we introduce a history-based operational semantics for open systems. This new semantics can be used as an intermediate step for proving that Creol's Hoare logic is sound and complete with respect to the language's operational semantics. The approach can easily be adapted to other component-based languages where communication is done by message passing or by method interaction.","Operational semantics, open distributed systems, communication histories, object orientation",,Creol,
E. B. Johnsen; O. Owe,Inheritance in the Presence of Asynchronous Method Calls,"This paper considers a formal object-oriented model for distributed computing. Object orientation appears as a leading framework for concurrent and distributed systems. However, the synchronization of the RPC communication model is unsatisfactory in many distributed systems. Asynchronous message passing gives better control and efficiency in this setting, but lacks the structure and discipline of traditional object-oriented methods. The integration of the message concept in the object-oriented paradigm is unsettled, especially with respect to inheritance and redefinition. We propose an approach combining asynchronous method calls and conditional processor release points, which reduces the cost of waiting for replies in the distributed environment while avoiding low-level synchronization constructs such as explicit signaling. Even the lack of replies to method calls in unstable environments need not lead to deadlock in the invoking objects. This property seems attractive in asynchronous, open, or unreliable environments. Furthermore, the approach allows active and passive behavior (client and server) to be combined in concurrent objects in a very natural way. In this paper, we consider the integration of these constructs with a mechanism for multiple inheritance within a small object-oriented language. The language constructs are formally described by an operational semantics defined in rewriting logic.",,distributed concurret o-o language,Creol PL,
"Malayeri D,Aldrich J",CZ: Multiple Inheritance without Diamonds,"Multiple inheritance has long been plagued with the \diamond\"" inheritance problem",leading to solutions that restrict expressiveness,,CZ,
"Danvy O,Johannsen J",Inter-deriving semantic artifacts for object-oriented programming,"We present a new abstract machine for Abadi and Cardelli's untyped non-imperative calculus of objects. This abstract machine mechanically corresponds to both the reduction semantics (i.e., small-step operational semantics) and the natural semantics (i.e., big-step operational semantics) specified in Abadi and Cardelli's monograph. To move closer to actual implementations, which use environments rather than actual substitutions, we then represent methods as closures and we present three new semantic artifacts for a version of Abadi and Cardelli's calculus with explicit substitutions: a reduction semantics, an environment-based abstract machine, and a natural semantics (i.e., an interpreter) with environments. These three new semantic artifacts mechanically correspond to each other, and the two abstract machines are bisimilar. Their significance lies in the fact that they have not been designed from scratch and then proved correct; instead, they have been inter-derived. To illustrate the inter-derivation and to make this article stand-alone, we also comprehensively treat the example of negational normalization over Boolean formulas, in appendix.","Functional calculus of objects, Reduction semantics, Abstract machine, Natural semantics, Syntactic correspondence, Functional correspondence",,"Danvy/Johansenn abstract machine
Abadi/Cardelli based",
"Gerakios P,Biboudis A,Smaragdakis Y",Forsaking Inheritance: Supercharged Delegation in DelphJ,"We propose DelphJ: a Java-based OO language that eschews inheritance completely, in favor of a combination of class morphing and (deep) delegation. Compared to past delegation approaches, the novel aspect of our design is the ability to emulate the best aspects of inheritance while retaining maximum flexibility: using morphing, a class can select any of the methods of its delegatee and export them (if desired) or transform them (e.g., to add extra arguments or modify type signatures), yet without needing to name these methods explicitly and handle them one-by-one. Compared to past work on morphing, our approach adopts and adapts advanced delegation mechanisms, in order to add late binding capabilities and, thus, provide a full substitute of inheritance. Additionally, we explore complex semantic issues in the interaction of delegation with late binding. We present our language design both informally, with numerous examples, and formally in a core calculus.","meta-programming, static reflection, language extensions, object composition, delegation, morphing",inheritace,DelphJ PL,
"Anderson C,Barbanera F,Dezani-Ciancaglini M,Drossopoulou S",Can Addresses be Types?: A case study: objects with delegation,"We adapt the aliasing constraints approach for designing a flexible typing of evolving objects. Types are singleton types (addresses of objects, as a matter of fact) whose relevance is mainly due to the sort of safety property they guarantee. In particular we provide a type system for an imperative object based calculus with delegation and which supports method and delegate overriding, addition, and removal.","object based calculi, delegation, alias types, effects","object calculi,
object type system,
delegation",delta calculus,
H. Jarvinen; R. Kurki-Suonio; M. Sakkinen; K. Systa,Object-oriented specification of reactive systems,"A novel approach to the operational specification of concurrent systems that leads to an object-oriented specification language is presented. In contrast to object-oriented programming languages, objects are structured as hierarchical state-transition systems, methods of individual objects are replaced by roles in cooperative multiobject actions whereby explicit mechanisms for process communication are avoided, and a simple nondeterministic execution model that requires no explicit invocation of actions is introduced. The approach has a formal basis, and it emphasizes structured derivation of specifications. Top-down and bottom-up methodologies are reflected in two variants of inheritance. The former captures the methodology of designing distributed systems by superimposition; the latter is suited to the specification of reusable modules.<<ETX>></ETX>",,DisCo,DisCo PL,
"Chugh R,Herman D,Jhala R",Dependent Types for JavaScript,"We present Dependent JavaScript (DJS), a statically typed dialect of the imperative, object-oriented, dynamic language. DJS supports the particularly challenging features such as run-time type-tests, higher-order functions, extensible objects, prototype inheritance, and arrays through a combination of nested refinement types, strong updates to the heap, and heap unrolling to precisely track prototype hierarchies. With our implementation of DJS, we demonstrate that the type system is expressive enough to reason about a variety of tricky idioms found in small examples drawn from several sources, including the popular book JavaScript: The Good Parts and the SunSpider benchmark suite.","strong updates, arrays, refinement types, JavaScript, prototype inheritance",,"DJS
DOT based",
"Castagna G,Chen G",Dependent Types with Subtyping and Late-Bound Overloading,"We present a calculus with dependent types, subtyping, and late-bound overloading. Besides its theoretical interest this work is motivated by several practical needs that range form the definition of logic encodings to proof specialization and reuse and to object-oriented extension of the SML module system. The theoretical study of this calculus is not straightforward. While confluence is relatively easy to prove, subject reduction is much harder. We were not able to add overloading to any existing system with dependent types and subtyping, and prove subject reduction. This is why we also define here as by-product a new subtyping system for dependent types that improves previous systems and enjoys several properties (notably the transitivity elimination property). The calculus with overloading is then obtained as a conservative extension of this new system. Another difficult point is strong normalization, which is a necessary condition to the decidability of subtyping and typing relations. The calculus with overloading is not strongly normalizing. However, we show that a reasonably useful fragment of the calculus enjoys this property and that its strong normalization implies the decidability of its subtyping and typing relations. The article is divided into two parts: the first three scetions provide a general overview of the systems and its motivations and can be read separately; the remaining sections develop the formal study.",,,DOT,
"Rompf T,Amin N",Type Soundness for Dependent Object Types (DOT),"Scala’s type system unifies aspects of ML modules, object- oriented, and functional programming. The Dependent Object Types (DOT) family of calculi has been proposed as a new theoretic foundation for Scala and similar expressive languages. Unfortunately, type soundness has only been established for restricted subsets of DOT. In fact, it has been shown that important Scala features such as type refinement or a subtyping relation with lattice structure break at least one key metatheoretic property such as environment narrowing or invertible subtyping transitivity, which are usually required for a type soundness proof. The main contribution of this paper is to demonstrate how, perhaps surprisingly, even though these properties are lost in their full generality, a rich DOT calculus that includes recursive type refinement and a subtyping lattice with intersection types can still be proved sound. The key insight is that subtyping transitivity only needs to be invertible in code paths executed at runtime, with contexts consisting entirely of valid runtime objects, whereas inconsistent subtyping contexts can be permitted for code that is never executed.","dependent object types, soundness, Scala, DOT",,DOT,
"Giarrusso PG,Stefanesco L,Timany A,Birkedal L,Krebbers R",Scala Step-by-Step: Soundness for DOT with Step-Indexed Logical Relations in Iris,"The metatheory of Scala’s core type system—the Dependent Object Types (DOT) calculus—is hard to extend, like the metatheory of other type systems combining subtyping and dependent types. Soundness of important Scala features therefore remains an open problem in theory and in practice. To address some of these problems, we use a semantics-first approach to develop a logical relations model for a new version of DOT, called guarded DOT (gDOT). Our logical relations model makes use of an abstract form of step-indexing, as supported by the Iris framework, to model various forms of recursion in gDOT. To demonstrate the expressiveness of gDOT, we show that it handles Scala examples that could not be handled by previous versions of DOT, and prove using our logical relations model that gDOT provides the desired data abstraction. The gDOT type system, its semantic model, its soundness proofs, and all examples in the paper have been mechanized in Coq.","type soundness, Iris, Coq, logical relations, Scala, step-indexing, data abstraction, DOT",,DOT,
Nieto A,Towards Algorithmic Typing for DOT (Short Paper),"The Dependent Object Types (DOT) calculus formalizes key features of Scala. The D<: calculus is the core of DOT. To date, presentations of D<: have used declarative, as opposed to algorithmic, typing and subtyping rules. Unfortunately, algorithmic typing for full D<: is known to be an undecidable problem. We explore the design space for a restricted version of D<: that has decidable typechecking. Even in this simplified D<:, algorithmic typing and subtyping are tricky, due to the \bad bounds\"" problem. The Scala compiler bypasses bad bounds at the cost of a loss in expressiveness in its type system. Based on the approach taken in the Scala compiler, we present the Step Typing and Step Subtyping relations for D<:. These relations are sound and decidable. They are not complete with respect to the original D<: typing rules.""",,,DOT,
"Amin N,Rompf T,Odersky M",Foundations of Path-Dependent Types,"A scalable programming language is one in which the same concepts can describe small as well as large parts. Towards this goal, Scala unifies concepts from object and module systems. An essential ingredient of this unification is the concept of objects with type members, which can be referenced through path-dependent types. Unfortunately, path-dependent types are not well-understood, and have been a roadblock in grounding the Scala type system on firm theory.We study several calculi for path-dependent types. We present DOT which captures the essence - DOT stands for Dependent Object Types. We explore the design space bottom-up, teasing apart inherent from accidental complexities, while fully mechanizing our models at each step. Even in this simple setting, many interesting patterns arise from the interaction of structural and nominal features.Whereas our simple calculus enjoys many desirable and intuitive properties, we demonstrate that the theory gets much more complicated once we add another Scala feature, type refinement, or extend the subtyping relation to a lattice. We discuss possible remedies and trade-offs in modeling type systems for Scala-like languages.","objects, dependent types, calculus",,DOT,
"Amin N,Rompf T",Type Soundness Proofs with Definitional Interpreters,"While type soundness proofs are taught in every graduate PL class, the gap between realistic languages and what is accessible to formal proofs is large. In the case of Scala, it has been shown that its formal model, the Dependent Object Types (DOT) calculus, cannot simultaneously support key metatheoretic properties such as environment narrowing and subtyping transitivity, which are usually required for a type soundness proof. Moreover, Scala and many other realistic languages lack a general substitution property. The first contribution of this paper is to demonstrate how type soundness proofs for advanced, polymorphic, type systems can be carried out with an operational semantics based on high-level, definitional interpreters, implemented in Coq. We present the first mechanized soundness proofs in this style for System F and several extensions, including mutable references. Our proofs use only straightforward induction, which is significant, as the combination of big-step semantics, mutable references, and polymorphism is commonly believed to require coinductive proof techniques. The second main contribution of this paper is to show how DOT-like calculi emerge from straightforward generalizations of the operational aspects of F, exposing a rich design space of calculi with path-dependent types inbetween System F and DOT, which we dub the System D Square. By working directly on the target language, definitional interpreters can focus the design space and expose the invariants that actually matter at runtime. Looking at such runtime invariants is an exciting new avenue for type system design.","type soundness, dependent object types, Scala, Definitional interpreters, DOT",,DOT,
"Kabir I,Li Y,Lhoták O",ιDOT: A DOT Calculus with Object Initialization,"The Dependent Object Types (DOT) calculus serves as a foundation of the Scala programming language, with a machine-verified soundness proof. However, Scala's type system has been shown to be unsound due to null references, which are used as default values of fields of objects before they have been initialized. This paper proposes ιDOT, an extension of DOT for ensuring safe initialization of objects. DOT was previously extended to κDOT with the addition of mutable fields and constructors. To κDOT, ιDOT adds an initialization effect system that statically prevents the possibility of reading a null reference from an uninitialized object. To design ιDOT, we have reformulated the Freedom Before Commitment object initialization scheme in terms of disjoint subheaps to make it easier to formalize in an effect system and prove sound. Soundness of ιDOT depends on the interplay of three systems of rules: a type system close to that of DOT, an effect system to ensure definite assignment of fields in each constructor, and an initialization system that tracks the initialization status of objects in a stack of subheaps. We have proven the overall system sound and verified the soundness proof using the Coq proof assistant.","type safety, DOT, Scala, dependent objects, initialization",,DOT,
"Rapoport M,Kabir I,He P,Lhoták O",A Simple Soundness Proof for Dependent Object Types,"Dependent Object Types (DOT) is intended to be a core calculus for modelling Scala. Its distinguishing feature is abstract type members, fields in objects that hold types rather than values. Proving soundness of DOT has been surprisingly challenging, and existing proofs are complicated, and reason about multiple concepts at the same time (e.g. types, values, evaluation). To serve as a core calculus for Scala, DOT should be easy to experiment with and extend, and therefore its soundness proof needs to be easy to modify. This paper presents a simple and modular proof strategy for reasoning in DOT. The strategy separates reasoning about types from other concerns. It is centred around a theorem that connects the full DOT type system to a restricted variant in which the challenges and paradoxes caused by abstract type members are eliminated. Almost all reasoning in the proof is done in the intuitive world of this restricted type system. Once we have the necessary results about types, we observe that the other aspects of DOT are mostly standard and can be incorporated into a soundness proof using familiar techniques known from other calculi.","DOT calculus, type safety, Scala, dependent object types",,DOT,
"Hong J,Park J,Ryu S",Path Dependent Types with Path-Equality,"While the Scala type system provides expressive features like objects with type members, the lack of equality checking between path-dependent types prohibits some programming idioms. One such an example is abstract domain combinators in implementing static analyzers. In this paper, we propose to extend the Scala type system with path-equality, and formalize it as a DOT variant, π DOT, which supports records with type members and elds. We show that π DOT has the normalization property and prove its type soundness.","path equality, Scala, DOT",,DOT,
"Rapoport M,Lhoták O",Mutable WadlerFest DOT,"The Dependent Object Types (DOT) calculus aims to model the essence of Scala, with a focus on abstract type members, path-dependent types, and subtyping. Other Scala features could be defined by translation to DOT.Mutation is a fundamental feature of Scala currently missing in DOT. Mutation in DOT is needed not only to model effectful computation and mutation in Scala programs, but even to precisely specify how Scala initializes immutable variables and fields (vals).We present an extension to DOT that adds typed mutable reference cells. We have proven the extension sound with a mechanized proof in Coq. We present the key features of our extended calculus and its soundness proof, and discuss the challenges that we encountered in our search for a sound design and the alternative solutions that we considered.",,,DOT based,
"Kabir I,Lhoták O",κDOT: Scaling DOT with Mutation and Constructors,"Scala unifies concepts from object and module systems by allowing for objects with type members which are referenced via path-dependent types. The Dependent Object Types (DOT) calculus of Amin et al. models only this core part of Scala, but does not have many fundamental features of Scala such as strict and mutable fields. Since the most commonly used field types in Scala are strict,the correspondence between DOT and Scala is too weak for us to meaningfully prove static analyses safe for Scala by proving them safe for DOT. A DOT calculus that can support strict and mutable fields together with constructors that do field initialization would be more suitable for analysis of Scala. Toward this goal, we present κDOT, an extension of DOT that supports constructors and field mutation and can emulate the different types of fields in Scala. We have proven κDOT sound through a mechanized proof in Coq. We present the key features of κDOT and its operational semantics and discuss work-in-progress toward making κDOT fully strict.","mutation, type safety, dependent object types",,DOT based,
Jeffery A,Dependent Object Types with Implicit Functions,"DOT (Dependent Object Types) is an object calculus with path-dependent types and abstract type members, developed to serve as a theoretical foundation for the Scala programming language. As yet, DOT does not model all of Scala's features, but a small subset. We present the calculus DIF (DOT with Implicit Functions), which extends the set of features modelled by DOT to include implicit functions, a feature of Scala to aid modularity of programs. We show type safety of DIF, and demonstrate that the generic programming focused use cases for implicit functions in Scala are also expressible in DIF.","Scala, implicit parameters, type classes, implicit functions, implicits, Dotty, DOT, objects, dependent object types, calculus",,DOT based,
"Rapoport M,Lhoták O",A Path to DOT: Formalizing Fully Path-Dependent Types,"The Dependent Object Types (DOT) calculus aims to formalize the Scala programming language with a focus on path-dependent types — types such as x.a1… an.T that depend on the runtime value of a path x.a1… an to an object. Unfortunately, existing formulations of DOT can model only types of the form x.A which depend on variables rather than general paths. This restriction makes it impossible to model nested module dependencies. Nesting small components inside larger ones is a necessary ingredient of a modular, scalable language. DOT’s variable restriction thus undermines its ability to fully formalize a variety of programming-language features including Scala’s module system, family polymorphism, and covariant specialization. This paper presents the pDOT calculus, which generalizes DOT to support types that depend on paths of arbitrary length, as well as singleton types to track path equality. We show that naive approaches to add paths to DOT make it inherently unsound, and present necessary conditions for such a calculus to be sound. We discuss the key changes necessary to adapt the techniques of the DOT soundness proofs so that they can be applied to pDOT. Our paper comes with a Coq-mechanized type-safety proof of pDOT. With support for paths of arbitrary length, pDOT can realize DOT’s full potential for formalizing Scala-like calculi.","Scala, paths, DOT, dependent types",,DOT based,
"Dovland J,Johnsen EB,Owe O,Steffen M",Lazy behavioral subtyping,"Inheritance combined with late binding allows flexible code reuse but complicates formal reasoning significantly, as a method call’s receiver class is not statically known. This is especially true when programs are incrementally developed by extending class hierarchies. This paper develops a novel method to reason about late bound method calls. In contrast to traditional behavioral subtyping, reverification of method specifications is avoided without restricting method overriding to fully behavior-preserving redefinition. The approach ensures that when analyzing the methods of a class, it suffices to consider that class and its superclasses. Thus, the full class hierarchy is not needed, and incremental reasoning is supported. We formalize this approach as a calculus which lazily imposes context-dependent subtyping constraints on method definitions. The calculus ensures that all method specifications required by late bound calls remain satisfied when new classes extend a class hierarchy. The calculus does not depend on a specific program logic, but the examples in the paper use a Hoare style proof system. We show soundness of the analysis method. The paper finally demonstrates how lazy behavioral subtyping can be combined with interface specifications to produce an incremental and modular reasoning system for object-oriented class hierarchies.","Object orientation, Inheritance, Code reuse, Late binding, Proof systems, Method redefinition, Incremental reasoning, Behavioral subtyping","calculus
lazy behavioral subtyping
object-oriented kernel language
based on Featherweight
Hoar-style proof","Dovland/Johnsen/Owe
calculus
Featherweight based
for lazy behavioral subtypig",
"Dovland J,Broch Johnsen E,Owe O,Steffen M",Incremental reasoning with lazy behavioral subtyping for multiple inheritance,"Object-orientation supports code reuse and incremental programming. Multiple inheritance increases the possibilities for code reuse, but complicates the binding of method calls and thereby program analysis. Behavioral subtyping allows program analysis under an open world assumption; i.e., under the assumption that class hierarchies are extensible. However, method redefinition is severely restricted by behavioral subtyping, and multiple inheritance may lead to conflicting restrictions from independently designed superclasses. This paper presents a more liberal approach to incremental reasoning for multiple inheritance under an open world assumption. The approach, based on lazy behavioral subtyping, is well-suited for multiple inheritance, as it incrementally imposes context-dependent behavioral constraints on new subclasses. We first present the approach for a simple language and show how incremental reasoning can be combined with flexible code reuse. Then this language is extended with a hierarchy of interface types which is independent of the class hierarchy. In this setting, flexible code reuse can be combined with modular reasoning about external calls in the sense that each class is analyzed only once. We formalize the approach as a calculus and show soundness for both languages.","Lazy behavioral subtyping, Object orientation, Multiple inheritance, Late binding, Proof systems, Code reuse, Method redefinition, Incremental reasoning",,"Dovland/Johnsen/Owe
calculus
for lazy behavioral subtypig",
"Dovland J,Johnsen EB,Owe O,Yu IC",A proof system for adaptable class hierarchies,"The code base of a software system undergoes changes during its life time. For object-oriented languages, classes are adapted, e.g., to meet new requirements, customize the software to specific user functionalities, or refactor the code to reduce its complexity. However, the adaptation of class hierarchies makes reasoning about program behavior challenging; even classes in the middle of a class hierarchy can be modified. This paper develops a proof system for analyzing the effect of operations to adapt classes, in the context of method overriding and late bound method calls. The proof system is incremental in the sense that reverification is avoided for methods that are not explicitly changed by adaptations. Furthermore, the possible adaptations are not unduly restricted; i.e., flexibility is retained without compromising on reasoning control. To achieve this balance, we extend the mechanism of lazy behavioral subtyping, originally proposed for reasoning about inheritance when subclasses are added to a class hierarchy, to deal with the more general situation of adaptable class hierarchies and changing specifications. The reasoning system distinguishes guaranteed method behavior from requirements toward methods, and achieves incremental reasoning by tracking guarantees and requirements in adaptable class hierarchies. We show soundness of the proposed proof system.","Software evolution, Object orientation, Verification, Proof systems, Class updates, Dynamic code modification",,"Dovland/Johnsen/Owe
calculus
for lazy behavioral subtypig

akin Featherweight",
"Damiani F,Dovland J,Johnsen EB,Schaefer I",Verifying Traits: A Proof System for Fine-Grained Reuse,"Traits have been proposed as a more flexible mechanism for code structuring in object-oriented programming than class inheritance, for achieving fine-grained code reuse. A trait originally developed for one purpose can be modified and reused in a completely different context. Formalizations of traits have been extensively studied, and implementations of traits have started to appear in programming languages. However, work on formally establishing properties of trait-based programs has so far mostly concentrated on type systems. This paper proposes the first deductive proof system for a trait-based object-oriented language. If a specification for a trait can be given a priori, covering all actual usage of that trait, our proof system is modular as each trait is analyzed only once. In order to reflect the flexible reuse potential of traits, our proof system additionally allows new specifications to be added to a trait in an incremental way which does not violate established proofs. We formalize and show the soundness of the proof system.","incremental reasoning, program verification, proof system, trait",,Dovland/Johnsen/Owe calculus for lazy behavioral subtypig,
"Furr M,An JH,Foster JS,Hicks M",Static Type Inference for Ruby,"Many general-purpose, object-oriented scripting languages are dynamically typed, which provides flexibility but leaves the programmer without the benefits of static typing, including early error detection and the documentation provided by type annotations. This paper describes Diamondback Ruby (DRuby), a tool that blends Ruby's dynamic type system with a static typing discipline. DRuby provides a type language that is rich enough to precisely type Ruby code we have encountered, without unneeded complexity. When possible, DRuby infers static types to discover type errors in Ruby programs. When necessary, the programmer can provide DRuby with annotations that assign static types to dynamic code. These annotations are checked at run time, isolating type errors to unverified code. We applied DRuby to a suite of benchmarks and found several bugs that would cause run-time type errors. DRuby also reported a number of warnings that reveal questionable programming practices in the benchmarks. We believe that DRuby takes a major step toward bringing the benefits of combined static and dynamic typing to Ruby and other object-oriented languages.","Ruby, type inference, contracts, dynamic typing",,DRuby,
Jianhua Qian; Yong Zheng; Liqun Jin; Jinhua Zhang,EASE: an embedded algebraic specification environment,"An attempt is made to apply ideas about algebraic specification in the context of a programming language, EASE, an embedded algebraic specification environment, is developed based on a Pascal-oriented iterative programming environment FPE by allowing embedded algebraic specification (EAS) in the place of Pascal code. It provides a framework for the formal development of a program from a specification. The authors discuss the design of EAS and the use of EASE as a term rewriting system. In general, EASE can automatically generate code for any formally specified object by term rewriting, and can immediately execute and test this object. Therefore, it can be used as a tool for support program development, program prototyping, and specification reuse.<<ETX>></ETX>",,,EASE,
Chen J,A Typed Intermediate Language for Supporting Interfaces,"Object-oriented languages such as Java and C# provide interfaces to support a restricted form of multiple inheritance. Existing low-level typed intermediate languages for object-oriented languages, however, either do not support interfaces or require non-standard interface implementations. This paper describes a low-level typed intermediate language that can express the standard interface implementation strategies based on interface tables (itables). The language can faithfully model itables, the standard itable-based interface method invocation, and interface cast. The type system is sound and the type checking is decidable.",,,ECI,
M. Aiguier,ÉTOILE-specifications: An Object-oriented Algebraic Formalism with Refinement,"In this paper, we investigate the formal specification of reactive systems described in an object-oriented style. We define a formalism, called ÉTOILE<sup>1</sup>-specifications, to deal with concurrent (active) object systems, and propose to extend algebraic approaches to dynamic and concurrent aspects by considering implicit states and implicit transitions, respectively. ÉTOILE-specifications emphasize systems composed of object types. Consequently, the ÉTOILE-formalism is split into two sub-formalisms. The first one enables us to specify the behaviour of object types. Then, it is extended from object types to systems by adding new requirements, mainly to describe the underlying architectural aspects of the system under specification (i.e. relationships between objects). The complexity of real systems results in the definition of formal means to manage their size. To deal with this issue, we propose a refinement of object type specifications by systems in the framework of ÉTOILE-specifications, which enables one to build his(her) specification in an incremental way.",Object-oriented specifications;algebraic specifications;dynamic logics;concurrency;algebraic refinement,Etoile,Etoile Model,
"Compagnoni A,Goguen H",Typed operational semantics for higher-order subtyping,"Bounded operator abstraction is a language construct relevant to object oriented programming languages and to ML2000, the successor to Standard ML. In this paper, we introduce Fω⩽, a variant of F<:ω with this feature and with Cardelli and Wegner’s kernel Fun rule for quantifiers. We define a typed-operational semantics with subtyping and prove that it is equivalent with Fω⩽, using logical relations to prove soundness. The typed-operational semantics provides a powerful and uniform technique to study metatheoretic properties of Fω⩽, such as Church–Rosser, subject reduction, the admissibility of structural rules, and the equivalence with the algorithmic presentation of the system that performs weak-head reductions. Furthermore, we can show decidability of subtyping using the typed-operational semantics and its equivalence with the usual presentation. Hence, this paper demonstrates for the first time that logical relations can be used to show decidability of subtyping.","Subtyping, Type theory, Typed-operational semantics, Lambda calculus, Dependent kinds",,"F omega based
Abadi/Cardelli based",
"Bruce KB,Cardelli L,Pierce BC",Comparing Object Encodings,"Recent years have seen the development of several foundational models for statically typed object-oriented programming. But despite their intuitive similarity, differences in the technical machinery used to formulate the various proposals have made them difficult to compare. Using the typed lambda-calculus Fω<: as a common basis, we now offer a detailed comparison of four models: (1) a recursive-record encoding similar to the ones used by Cardelli, Reddy, Cook, and others; (2) Hofmann, Pierce, and Turner's existential encoding; (3) Bruce's model based on existential and recursive types; and (4) Abadi, Cardelli, and Viswanathan's type-theoretic encoding of a calculus of primitive objects.",,,"F omega based
Abadi/Cardelli based",comparison
"Zhang Y,Myers AC","Familia: Unifying Interfaces, Type Classes, and Family Polymorphism","Parametric polymorphism and inheritance are both important, extensively explored language mechanisms for providing code reuse and extensibility. But harmoniously integrating these apparently distinct mechanisms—and powerful recent forms of them, including type classes and family polymorphism—in a single language remains an elusive goal. In this paper, we show that a deep unification can be achieved by generalizing the semantics of interfaces and classes. The payoff is a significant increase in expressive power with little increase in programmer-visible complexity. Salient features of the new programming language include retroactive constraint modeling, underpinning both object-oriented programming and generic programming, and module-level inheritance with further-binding, allowing family polymorphism to be deployed at large scale. The resulting mechanism is syntactically light, and the more advanced features are transparent to the novice programmer. We describe the design of a programming language that incorporates this mechanism; using a core calculus, we show that the type system is sound. We demonstrate that this language is highly expressive by illustrating how to use it to implement highly extensible software and by showing that it can not only concisely model state-of-the-art features for code reuse, but also go beyond them.","Familia, language design, extensibility, type classes, family polymorphism, genericity, type-safety",,FAMILIA,
"Bettini L,Damiani F,Geilmann K,Schäfer J",Combining traits with boxes and ownership types in a Java-like setting,"The box model is a lightweight component model for the object-oriented paradigm, which structures the flat object-heap into hierarchical runtime components called boxes. Boxes have clear runtime boundaries that divide the objects of a box into objects that can be used to interact with the box (the boundary objects) and objects that are encapsulated and represent the state of the box (the local objects). The distinction into local and boundary objects is statically achieved by an ownership type system for boxes that uses domain annotations to classify objects into local and boundary objects and that guarantees that local objects can never be directly accessed by the context of a box. A trait is a set of methods divorced from any class hierarchy. Traits are units of fine-grained reuse that can be composed together to form classes or other traits. This paper integrates traits into an ownership type system for boxes. This combination is fruitful in two ways: it can statically guarantee encapsulation of objects and still provide fine-grained reuse among classes that goes beyond the possibilities of standard inheritance. It also solves a specific problem of the box ownership type system: namely that box classes cannot inherit from standard classes (and vice versa), and thus code sharing between these two kinds of classes was not possible in this setting so far. We present an ownership type system and the corresponding soundness proofs that guarantee encapsulation of objects in an object-oriented language with traits.","Boxes, Featherweight Java, Ownership types, Traits",,Featherweight based,
"Rowe RN,van Bakel SJ",Semantic Types and Approximation for Featherweight Java,"We consider semantics for the class-based object-oriented calculus Featherweight Java (without casts) based upon approximation. We also define an intersection type assignment system for this calculus and show that it satisfies subject reduction and expansion, i.e. types are preserved under reduction and its converse. We establish a link between type assignment and the approximation semantics by showing an approximation result, which leads to a sufficient condition for the characterisation of head-normalisation and termination. We show the expressivity of both our calculus and our type system by defining an encoding of Combinatory Logic into our calculus and showing that this encoding preserves typeability. We also show that our system characterises the normalising and strongly normalising terms for this encoding. We thus demonstrate that the great analytic capabilities of intersection types can be applied to the context of class-based object orientation.","Featherweight Java, Intersection types, Approximation semantics, Derivation reduction, Strong normalisation",,Featherweight based,
"Bettini L,Capecchi S,Damiani F",On flexible dynamic trait replacement for Java-like languages,"Dynamic trait replacement is a programming language feature for changing the objects’ behavior at runtime by replacing some of the objects’ methods. In previous work on dynamic trait replacement for Java-like languages, the objects’ methods that may be replaced must correspond exactly to a named trait used in the object’s class definition. In this paper we propose the notion of replaceable: a programming language feature that decouples the trait replacement operation code and the class declaration code, thus making it possible to refactor classes and to perform unanticipated trait replacement operations without invalidating existing code. We give a formal account of our proposal through a core calculus, FDTJ (Featherweight Dynamic Trait Java), equipped with a static type system guaranteeing that in a well-typed program no runtime type error will take place.","Featherweight Java, Trait, Type system",,Featherweight based,
"Iosif-Lazăr AF,Wąsowski A",Trustworthy variant derivation with translation validation for safety critical product lines,"Software product line (SPL) engineering facilitates development of entire families of software products with systematic reuse. Model driven SPLs use models in the design and development process. In the safety critical domain, validation of models and testing of code increases the quality of the products altogether. However, to maintain this trustworthiness it is necessary to know that the SPL tools, which manipulate models and code to derive concrete product variants, do not introduce errors in the process. We propose a general technique of checking correctness of product derivation tools through translation validation. We demonstrate it using Featherweight VML—a core language for separate variability modeling relying on a single kind of variation point to define transformations of artifacts seen as object models. We use Featherweight VML with its semantics as a correctness specification for validating outputs of a variant derivation tool. We embed this specification in the theorem proving system Coq and develop an automatic generator of correctness proofs for translation results within Coq. We show that the correctness checking procedure is decidable, which allows the trustworthy proof checker of Coq to automatically verify runs of a variant derivation tool for correctness. We demonstrate how such a simple validation system can be constructed, by using this to validate variant derivation of a simple variability model implementation based on the Eclipse Modeling Framework. We hope that this presentation will encourage other researchers to use translation validation to validate more complex correctness properties in handling variability, as well as demonstrate to commercial tool vendors that formal verification can be introduced into their tools in a very lightweight manner.",,,Featherweight based,
"da Silva Feitosa S,Ribeiro RG,Du Bois AR",Property-Based Testing for Lambda Expressions Semantics in Featherweight Java,"The release of Java 8 represents one of the most significant updates to the Java language since its inception. The addition of λ-expressions allows the treatment of code as data in a compact way, improving the language expressivity. This paper addresses the problem of defining rigorous semantics for new features of Java, such as λ-expressions and default methods, using Featherweight Java (FJ), a well-known object-oriented calculus. To accomplish this task, we embed the formalization of these new features in two different semantics, checking them for safety properties using QuickCheck, a property-based testing library for Haskell.","property-based testing, featherweight Java, λ-expressions",,Featherweight based,
"Feitosa SS,Mena AS,Ribeiro RG,Bois AR",An Inherently-Typed Formalization for Featherweight Java,"Featherweight Java is one of the most popular calculi which specify object-oriented programming features. It has been used as the basis for investigating novel language functionalities, as well as to specify and understand the formal properties of existing features for languages in this paradigm. However, when considering mechanized formalization, it is hard to find an implementation for languages with complex structures and binding mechanisms as Featherweight Java. In this paper we explore an inherently-typed approach to formalize Featherweight Java, implementing the static and dynamic semantics in Agda using dependent types, and then replicating it in Coq (the latter using the Equations plug-in). Using this approach, the interpreter is correct by construction, since the type checker of the host language is responsible for verifying type safety, thus avoiding repetitions of proofs and error checking.","Featherweight Java, Dependent Types, Agda, Mechanized Semantics",,Featherweight based,
"Racordon D,Buchs D",Featherweight Swift: A Core Calculus for Swift’s Type System,"Swift is a modern general-purpose programming language, designed to be a replacement for C-based languages. Although primarily directed at development of applications for Apple's operating systems, Swift's adoption has been growing steadily in other domains, ranging from server-side services to machine learning. This success can be partly attributed to a rich type system that enables the design of safe, fast, and expressive programming interfaces. Unfortunately, this richness comes at the cost of complexity, setting a high entry barrier to exploit Swift's full potential. Furthermore, existing documentation typically only relies on examples, leaving new users with little help to build a deeper understanding of the underlying rules and mechanisms. This paper aims to tackle this issue by laying out the foundations for a formal framework to reason about Swift's type system. We introduce Featherweight Swift, a minimal language stripped of all features not essential to describe its typing rules. Featherweight Swift features classes and protocol inheritance, supports retroactive modeling, and emulates Swift's overriding mechanisms. Yet its formalization fits on a few pages. We present Featherweight Swift's syntax and semantics. We then elaborate on the usability of our framework to reason about Swift's features, future extensions, and implementation by discussing a bug in Swift's compiler, discovered throughout the design of our calculus.","language semantics, language calculus, type systems, swift, protocol oriented programming",,"Featherweight Swift
Featherweight based",
"Ina L,Igarashi A",Gradual Typing for Generics,"Gradual typing is a framework to combine static and dynamic typing in a single programming language. In this paper, we develop a gradual type system for class-based object-oriented languages with generics. We introduce a special type to denote dynamically typed parts of a program; unlike dynamic types introduced to C# 4.0, however, our type system allows for more seamless integration of dynamically and statically typed code.We formalize a gradual type system for Featherweight GJ with a semantics given by a translation that inserts explicit run-time checks. The type system guarantees that statically typed parts of a program do not go wrong, even if it includes dynamically typed parts. We also describe a basic implementation scheme for Java and report preliminary performance evaluation.","gradual typing, generics, dynamic types",,"FeatherweightGJ
Featherweight based",
"Apel S,Kästner C,Lengauer C",Feature Featherweight Java: A Calculus for Feature-Oriented Programming and Stepwise Refinement,"Feature-oriented programming (FOP) is a paradigm that incorporates programming language technology, program generation techniques, and stepwise refinement. In their GPCE'07 paper, Thaker et al. suggest the development of a type system for FOP to guarantee safe feature composition, i.e, to guarantee the absence of type errors during feature composition. We present such a type system along with a calculus for a simple feature-oriented, Java-like language, called Feature Featherweight Java (FFJ). Furthermore, we explore four extensions of FFJ and how they affect type soundness.","stepwise refinement, feature-oriented programming, type systems, safe feature composition, featherweight java",,"FFJ
Featherweight based",
"Park G,Hong J,Steele Jr GL,Ryu S",Polymorphic Symmetric Multiple Dispatch with Variance,"Many object-oriented languages provide method overloading, which allows multiple method declarations with the same name. For a given method invocation, in order to choose what method declaration to invoke, multiple dispatch considers the run-time types of the arguments. While multiple dispatch can support binary methods (such as mathematical operators) intuitively and consistently, it is difficult to guarantee that calls will be neither ambiguous nor undefined at run time, especially in the presence of expressive language features such as multiple inheritance and parametric polymorphism. Previous efforts have formalized languages that include such features by using overloading rules that guarantee a unique and type-sound resolution of each overloaded method call; in many cases, such rules resolve ambiguity by treating the arguments asymmetrically. Here we present the first formal specification of a strongly typed object-oriented language with symmetric multiple dispatch, multiple inheritance, and parametric polymorphism with variance. We define both a static (type- checking) semantics and a dynamic (dispatching) semantics and prove the type soundness of the language, thus demonstrating that our novel dynamic dispatch algorithm is consistent with the static semantics. Details of our dynamic dispatch algorithm address certain technical challenges that arise from structural asymmetries inherent in object-oriented languages (e.g., classes typically declare ancestors explicitly but not descendants).","Variance, Parametric Polymorphism, Symmetric Multiple Dispatch, Method Overloading",,FGFV,
Ghelli G,Foundations for Extensible Objects with Roles,"Object-oriented database systems are an emerging, promising technology, underpinned by the integration of ideas from object-oriented languages along with the specific needs of database applications. The fundamental reason for using such systems is that any real-world entity can be modeled by one object which matches its structure and behavior. To this end, the standard notion of object must be augmented so that it can model the fact that an entity may acquire new pieces of structure and behavior during its existence without changing its identity. To allow this extensibility in a statically typed system, a notion of context-dependent behavior (role playing) must be added to the basic features of object-oriented languages. This feature is also a useful modeling device. Languages with role mechanisms have already been proposed. However, their design is full of choices which cannot be easily justified. A strong foundation for the object-with-roles notion would be extremely helpful to justify these choices and to understand, and prove, the properties of such a mechanism. In this paper we describe such a foundation, building on the object model proposed by Abadi and Cardelli.",,,"Fibonacci 
PL",database PL
"Servetto M,Groves L",True Small-Step Reduction for Imperative Object Oriented Languages,"Traditionally, formal semantic models of Java-like languages use an explicit model of the store which mimics pointers and ram. These low level models hamper understanding of the semantics, and development of proofs about ownerships and other encapsulation properties, since the real (graph) structure of the data is obscured by the encoding. Such models are also inadequate for didactic purposes since they rely on run-time structures that do not exist in the source program --- in order to understand the meaning of an expression in the middle of the execution one is required to visualize the memory structure which is hard to relate to the abstract program state.We present a semantic model for Java-like languages where data is encoded as part of the program rather than as a separate resource. This means that execution can be modelled more simply by just rewriting source code terms, as in semantic models for functional programs. The major challenges that need to be addressed are aliasing, circular object graphs, exceptions and multiple return methods. In this initial proposal we use local variable declarations in order to tackle aliasing and circular object graphs.","small-step reduction, object oriented, imperative languages",,FJ,
"Barbieri P,Dagnino F,Zucca E",An Inductive Abstract Semantics for CoFJ,"We describe an inductive abstract semantics for coFJ, a Java-like calculus where, when the same method call is encountered twice, non-termination is avoided, and the programmer can decide the behaviour in this case, by writing a codefinition. The proposed semantics is abstract in the sense that evaluation is non-deterministic, and objects are possibly infinite. However, differently from typical coinductive handling of infinite values, the semantics is inductive, since it relies on detection of cyclic calls. Whereas soundness with respect to the reference coinductive semantics has already been proved, we conjecture that completeness with respect to the regular subset of such semantics holds as well. This relies on the fact that in the proposed semantics detection of cycles is non-deterministic, that is, does not necessarily happens the first time a cycle is found.","programming paradigms, coinduction, Operational semantics, regular terms",,"FJ based
CoFJ",
"Lagorio G,Servetto M,Zucca E",Featherweight Jigsaw — Replacing inheritance by composition in Java-like languages,"We present FJig, a simple calculus where basic building blocks are classes in the style of Featherweight Java, declaring fields, methods and one constructor. However, inheritance has been generalized to the much more flexible notion originally proposed in Brachaʼs Jigsaw framework. That is, classes play also the role of modules, that can be composed by a rich set of operators, all of which can be expressed by a minimal core. Fields and methods can be declared of four different kinds (abstract, virtual, frozen, local) determining how they are affected by the operators. We keep the nominal approach of Java-like languages, that is, types are class names. However, a class is not necessarily a structural subtype of any class used in its defining expression. While this allows a more flexible reuse, it may prevent the (generalized) inheritance relation from being a subtyping relation. So, the required subtyping relations among classes are declared by the programmer and checked by the type system. The calculus allows the encoding of a large variety of different mechanisms for software composition in class-based languages, including standard inheritance, mixin classes, traits and hiding. Hence, FJig can be used as a unifying framework for analyzing existing mechanisms and proposing new extensions. We provide two different semantics of an FJig program: flattening and direct semantics. The difference is analogous to that between two intuitive models to understand inheritance: the former where inherited methods are copied into heir classes, and the latter where member lookup is performed by ascending the inheritance chain. Here we address equivalence of these two views for a more sophisticated composition mechanism.",,,"FJig
Featherweight based",
"Corradi A,Servetto M,Zucca E",DeepFJig: Modular Composition of Nested Classes,"We present a new language design which smoothly integrates modular composition and nesting of Java-like classes. That is, inheritance has been replaced by an expressive set of composition operators, inspired by Bracha's Jigsaw framework, and these operators allow to manipulate (e.g., rename or duplicate) a nested class at any level of depth. Typing is nominal as characteristic of Java-like languages, so types are paths of the form outern. c1..... ck which, depending on the class (node) where they occur, denote another node in the nesting tree. However, paths denoting the same class are not equivalent, since they behave differently w.r.t. composition operators.The resulting language, called DeepFJig, obtains a great expressive power, allowing, e.g., to solve the expression problem, encode basic AOP mechanisms, and bring some refactoring techniques at the language level, while keeping a very simple semantics and type system which represent a natural extension for, say, a Java programmer.","Java, module composition, nested classes",,"FJig based
DeepFJig
PL",
"Ancona D,Corradi A",A Formal Account of SSA in Java-like Languages,"Static Single Assignment (SSA) intermediate representation is widely used to optimize and compile code in imperative and object-oriented languages, but it can also be useful for static type analysis.We introduce FJSSA, a Java-like imperative calculus supporting programs in SSA form; we define its big-step operational semantics, and a judgment to statically check whether a program is in SSA form, and prove its soundness.FJSSA provides a formal basis for type analysis of programs in SSA form in object-oriented languages.","type analysis, operational semantics, object-oriented languages, SSA form",,FJSSA,
M. Abbas; C. Ben-Yelles; R. Rioboo,Formalizing UML/OCL Multiple Inheritance with FoCaLiZe,"Multiple Inheritance is an Object Oriented feature that is widely adopted by the Unified Modeling Language (UML). To generate software from a UML model, programming languages that supports multiple inheritance (such as C++, Eiffel or POOL) are available. But, when it is necessary to check and analyze model properties, it is relevant to use formal methods (environments) that help developers to specify and check such properties. In this paper, we propose a formal transformation of UML multiple inheritance into FoCaLiZe, a formal programming environment using a proof-based approach. The transformation naturally captures multiple inheritance of classes attributes, methods and OCL constraints with methods overriding and late binding mechanisms. This transformation enables to specify theoretical and critical systems properties. In addition, it is possible to check and prove such properties using the automatic theorem prover of FoCaLiZe.",Multiple Inheritance semantics;Functional programming;Software Engineering;FoCaLiZe;UML;OCL;Verification,FoCaLiZe,FoCaLiZe Prover,
Liu Yan; Li Ying; Dai Yisong,The analysis and design of a FOMT-C++ compiler,"This paper discusses the lack of formality in OMT (Object Modeling Technique), presents a system framework of formal OMT and presents research on the automatic translation problem from formal OMT to C++. Firstly, this paper discusses the grammar of FOMT, formal semantics and determination of translating functions. Then it considers the design and implementation of the translation system.",,,FOMT,
"Gerakios P,Fourtounis G,Smaragdakis Y",Fᴏᴏ: A Minimal Modern OO Calculus,"We present the Flyweight Object-Oriented (Fᴏᴏ) calculus for the modeling of object-oriented languages. Fᴏᴏ is a simple, minimal class-based calculus, modeling only essential computational aspects and emphasizing larger-scale features (e.g., inheritance and generics). Fᴏᴏ is motivated by the observation that recent language design work focuses on elements not well-captured either by traditional object calculi or by language-specific modeling efforts, such as Featherweight Java. Fᴏᴏ integrates seamlessly both nominal and structural subtyping ideas, leveraging the latter to eliminate the need for modeling object fields and constructors. Comparing to recent formalization efforts in the literature, Fᴏᴏ is more compact, yet versatile enough to be usable in multiple settings modeling Java, C#, or Scala extensions.","object-oriented programming, type system, formal semantics, nominal types, structural types",,"Foo calculus
Featherweight based",
J. F. Baldwin; T. P. Martin,Fuzzy classes in object-oriented logic programming,"Object-oriented programming has been widely adopted as a powerful programming paradigm, enabling software engineers to design systems using structures which map naturally onto the problem domain. Using ideas from logic programming, a class definition can be treated as a logic theory, making it amenable to formal reasoning. Each class corresponds to a set of objects in the problem domain. We extend this idea, so that an object may have a degree of membership in more than one class, i.e. each class represents a fuzzy set of objects in the problem domain. Uncertainty is also allowed in data values and computational methods associated with objects. The problem of multiple inheritance is addressed by including methods for resolving conflict in class definitions. A system is being implemented in Fril, to allow development of fuzzy object oriented knowledge-based applications. This system is known as Fril++. The ideas are also applicable to other logic programming systems, assuming a method can be programmed at the object or meta-level to deal with uncertainty in terms, relations, and inference.",,Fril,Fril Model,
"Liquori L,Spiwack A",FeatherTrait: A Modest Extension of Featherweight Java,"In the context of statically typed, class-based languages, we investigate classes that can be extended with trait composition. A trait is a collection of methods without state; it can be viewed as an incomplete stateless class. Traits can be composed in any order, but only make sense when imported by a class that provides state variables and additional methods to disambiguate conflicting names arising between the imported traits. We introduce FeatherTrait Java (FTJ), a conservative extension of the simple lightweight class-based calculus Featherweight Java (FJ) with statically typed traits. In FTJ, classes can be built using traits as basic behavioral bricks; method conflicts between imported traits must be resolved explicitly by the user either by (i) aliasing or excluding method names in traits, or by (ii) overriding explicitly the conflicting methods in the class or in the trait itself. We present an operational semantics with a lookup algorithm, and a sound type system that guarantees that evaluating a well-typed expression never yields a message-not-understood run-time error nor gets the interpreter stuck. We give examples of the increased expressive power of the trait-based inheritance model. The resulting calculus appears to be a good starting point for a rigorous mathematical analysis of typed class-based languages featuring trait-based inheritance.","language design, inheritance, Java, language semantics",,"FTJ
Featherweight based",
"Breazu-Tannen V,Coquand T,Gunter CA,Scedrov A",Inheritance as implicit coercion,"We present a method for providing semantic interpretations for languages with a type system featuring inheritance polymorphism. Our approach is illustrated on an extension of the language Fun of Cardelli and Wegner, which we interpret via a translation into an extended polymorphic lambda calculus. Our goal is to interpret inheritances in Fun via coercion functions which are definable in the target of the translation. Existing techniques in the theory of semantic domains can be then used to interpret the extended polymorphic lambda calculus, thus providing many models for the original language. This technique makes it possible to model a rich type discipline which includes parametric polymorphism and recursive types as well as inheritance. A central difficulty in providing interpretations for explicit type disciplines featuring inheritance in the sense discussed in this paper arises from the fact that programs can type-check in more than one way. Since interpretations follow the type-checking derivations, coherence theorems are required: that is, one must prove that the meaning of a program does not depend on the way it was type-checked. Proofs of such theorems for our proposed interpretation are the basic technical results of this paper. Interestingly, proving coherence in the presence of recursive types, variants, and abstract types forced us to reexamine fundamental equational properties that arise in proof theory (in the form of commutative reductions) and domain theory (in the form of strict vs. non-strict functions).",,Fun ,"Fun
Abadi/Cardelli based",
K. B. Bruce; G. Longo,"A modest model of records, inheritance and bounded quantification","The authors give a formal semantics for the language Bounded Fun, which supports both parametric and subtype polymorphism. They show how to use partial equivalence relations to model inheritance in this language, which supports the notion of subtype and record types. A generalization of partial equivalence relations, known as omega -sets, is used in combination with modest sets to provide the first known model of Bounded Fun (with explicit polymorphism). Connections with previous work on the semantics of explicit parametric polymorphism is established by noting that the semantics of polymorphic types presented here (using dependent products) is isomorphic to that given by the intersection interpretation of polymorphism.<<ETX>></ETX>",,,"Fun
abadi/cardelli based",
"Parkinson MJ,Bierman GM","Separation Logic, Abstraction and Inheritance","Inheritance is a fundamental concept in object-oriented programming, allowing new classes to be defined in terms of old classes. When used with care, inheritance is an essential tool for object-oriented programmers. Thus, for those interested in developing formal verification techniques, the treatment of inheritance is of paramount importance. Unfortunately, inheritance comes in a number of guises, all requiring subtle techniques.To address these subtleties, most existing verification methodologies typically adopt one of two restrictions to handle inheritance: either (1) they prevent a derived class from restricting the behaviour of its base class (typically by syntactic means) to trivialize the proof obligations; or (2) they allow a derived class to restrict the behaviour of its base class, but require that every inherited method must be reverified. Unfortunately, this means that typical inheritance-rich code either cannot be verified or results in an unreasonable number of proof obligations.In this paper, we develop a separation logic for a core object-oriented language. It allows derived classes which override the behaviour of their base class, yet supports the inheritance of methods without reverification where this is safe. For each method, we require two specifications: a static specification that is used to verify the implementation and direct method calls (in Java this would be with a super call); and a dynamic specification that is used for calls that are dynamically dispatched; along with a simple relationship between the two specifications. Only the dynamic specification is involved with behavioural subtyping. This simple separation of concerns leads to a powerful system that supports all forms of inheritance with low proof-obligation overheads. We both formalize our methodology and demonstrate its power with a series of inheritance examples.","classes, modularity, separation logic",,"FVC
Featherweight based",
"Tardieu O,Nystrom N,Peshansky I,Saraswat V",Constrained Kinds,"Modern object-oriented languages such as X10 require a rich framework for types capable of expressing both value-dependency and genericity, and supporting pluggable, domain-specific extensions. In earlier work, we presented a framework for constrained types in object-oriented languages, parametrized by an underlying constraint system. Types are viewed as formulas Cc where C is the name of a class or an interface and c is a constraint on the immutable instance state (the properties) of C. Constraint systems are a very expressive framework for partial information. Many (value-)dependent type systems for object-oriented languages can be viewed as constrained types.This paper extends the constrained types approach to handle type-dependency (\genericity\""). The key idea is to introduce constrained kinds: in the same way that constraints on values can be used to define constrained types",constraints on types can define constrained kinds.We develop a core programming language with constrained kinds. Generic types are supported by introducing type variables---literally,,"FXG
Featherweight based",
"Apel S,Hutchins D",A Calculus for Uniform Feature Composition,"The goal of feature-oriented programming (FOP) is to modularize software systems in terms of features. A feature refines the content of a base program. Both base programs and features may contain various kinds of software artifacts, for example, source code in different languages, models, build scripts, and documentation. We and others have noticed that when composing features, different kinds of software artifacts can be refined in a uniform way, regardless of what they represent. We present gDeep, a core calculus for feature composition, which captures the language independence of FOP; it can be used to compose features containing many different kinds of artifact in a type-safe way. The calculus allows us to gain insight into the principles of FOP and to define general algorithms for feature composition and validation. We provide the formal syntax, operational semantics, and type system of gDeep and outline how languages like Java, Haskell, Bali, and XML can be plugged in.","Feature-oriented programming, type systems, principle of uniformity, feature composition",,gDeep,
"Lago JM,Artalejo MR",A declarative framework for object-oriented programming with genetic inheritance,"Seeking the integration of the object-oriented and declarative programming paradigms offers advantages for the software life-cycle activities. Specification is benefited from using declarative expressions as functional descriptions of components, enjoying formal semantic models. But the integration of both paradigms, object-oriented and declarative, following a translation scheme sets an unavoidable representation distance. Classes, inheritance, attributes and methods are codified with abstract elements, thus not being primitive. This work aims to offer a declarative formal model where the main features of object-oriented programming are nuclear, focusing in an algebraic formalization of purely functional objects. Substantially extending (Mateos-Lago and Rodrı́guez-Artalejo, PLILP’96, Lecture Notes in Computer Science, Vol. 1140, Springer, Berlin, 1996, pp. 62–76), we include operations to homogeneously model methods and class-external functions. Multiple inheritance is supported and extended with genetic inheritance and expressions are flexibly typed using genome typing. Following (González-Moreno et al., J. Logic Programming 40(1) (1999) 47), we use a rewriting logic as a technical tool that helps to formalize the semantics based on continuous algebras (Goguen et al., J. ACM 24(1) (1977) 68), and we show initiality with the existence of a distinguished model for program semantics.","Object-oriented declarative programming, Genetic inheritance, Algebraic semantics, Paradigm integration",,GOTA,
"Muehlboeck F,Tate R",Sound Gradual Typing is Nominally Alive and Well,"Recent research has identified significant performance hurdles that sound gradual typing needs to overcome. These performance hurdles stem from the fact that the run-time checks gradual type systems insert into code can cause significant overhead. We propose that designing a type system for a gradually typed language hand in hand with its implementation from scratch is a possible way around these and several other hurdles on the way to efficient sound gradual typing. Such a design process also highlights the type-system restrictions required for efficient composition with gradual typing. We formalize the core of a nominal object-oriented language that fulfills a variety of desirable properties for gradually typed languages, and present evidence that an implementation of this language suffers minimal overhead even in adversarial benchmarks identified in earlier work.","Nominal, Transparency, Immediate Accountability, Gradual Typing",,gradual typing based,
de Oliveira Guimarães J,The Green language,"Green is a statically typed object-oriented language which supports parameterized classes, metaobjects, introspective reflection, and classes as first-class objects. Its exception system is completely object-oriented for it encapsulates in classes not only exceptions but also exception handling. The language definition of subtyping is more encompassing than subclassing, thus improving polymorphism. Classes are classless objects which have themselves types. This makes classes first-class objects without the problems associated with languages in which every class is an object of another class, its metaclass. Every basic value such as 7 or ‘A’ is considered as an object whenever necessary which makes programming easy and increases polymorphism.","Object-oriented languages, Type systems, Polymorphism, Exception handling system",,"Green
PL",
J. de Oliveira Guimar,The Green Language Exception System,"Exception systems have become popular because they uncouple error detection and handling thus allowing us to produce better software. However, the exception handling systems of many object-oriented languages benefit very little from object-oriented programming. The catch clauses following a try block are isolated pieces of code: they do not belong to classes and cannot be reused. This paper presents the object-oriented exception system of the Green language, which fully uses the object-oriented programming features. These include the use of classes, types and subtyping, objects and inheritance. The result is a powerful exception system completely integrated with the language.",,Green,Green PL,
de Oliveira Guimarães J,The Green language type system,"A programming language that considers basic values and classes as objects brings more opportunities of code reuse and it is easier to use than a language that does not support this feature. However, popular statically typed object-oriented languages do not consider classes as first-class objects because this concept is difficult to integrate with static type checking. They also do not consider basic values as objects for sake of efficiency. This article presents the Green language type system which supports classes as classless objects and offers a mechanism to treat basic values as objects. The result is a reasonably simple type system which is statically typed and easy to implement. It simplifies several other language mechanisms and prevents any infinite regression of metaclasses.","Object-oriented languages, Green, Type system, Polymorphism",,Green PL,
"Dietl W,Drossopoulou S,Müller P",Separating Ownership Topology and Encapsulation with Generic Universe Types,"Ownership is a powerful concept to structure the object store and to control aliasing and modifications of objects. This article presents an ownership type system for a Java-like programming language with generic types.Like our earlier Universe type system, Generic Universe Types structure the heap hierarchically. In contrast to earlier work, we separate the enforcement of an ownership topology from an encapsulation system. The topological system uses an existential modifier to express that no ownership information is available statically. On top of the topological system, we build an encapsulation system that enforces the owner-as-modifier discipline. This discipline does not restrict aliasing, but requires modifications of an object to be initiated by its owner. This allows owner objects to control state changes of owned objects—for instance, to maintain invariants. Separating the topological system from the encapsulation system allows for a cleaner formalization, separation of concerns, and simpler reuse of the individual systems in different contexts.","ownership types, owner-as-modifier, generic, Encapsulation, universe types, topology",,"GUT
ownership types based",
D. Hedin; D. Sands,Noninterference in the presence of non-opaque pointers,"A common theoretical assumption in the study of information flow security in Java-like languages is that pointers are opaque - i.e., that the only properties that can be observed of pointers are the objects to which they point, and (at most) their equality. These assumptions often fail in practice. For example, various important operations in Java's standard API, such as hashcodes or serialization, might break pointer opacity. As a result, information-flow static analyses which assume pointer opacity risk being unsound in practice, since the pointer representation provides an unchecked implicit leak. We investigate information flow in the presence of non-opaque pointers for an imperative language with records, pointer instructions and exceptions, and develop an information flow aware type system which guarantees noninterference",,,Hedin/Sands type system,
J. Hoffman,A practical notation for object oriented analysis with a formal meaning,"A more formal approach to object oriented information modeling (H. Kilov and J. Ross, 1994) is proposed. The five basic associations (dependency, reference, composition, subtyping and symmetric relationship) are defined mathematically, but may still be used in a graphical notation in a user friendly way. In this way, it is possible to obtain an information model with a strict mathematical meaning without additional effort.",,,"Hoffman model
Kilov/Ross model based","ref Haim Kilov and James Ross. Information modeling: an object-oriented approach. Prentice Hall, 1994"
Reddy US,Objects and Classes in Algol-Like Languages,"Many object-oriented languages used in practice descend from Algol. With this motivation, we study the theoretical issues underlying such languages via the theory of Algol-like languages. It is shown that the basic framework of this theory extends cleanly and elegantly to the concepts of objects and classes. Moreover, a clear correspondence emerges between classes and abstract data types, whose theory corresponds to that of existential types. Equational and Hoare-like reasoning methods and relational parametricity provide powerful formal tools for reasoning about Algol-like object-oriented programs.",,,"IA+
PL
lambda calculus based",ref The Idealized Algol of Reynolds
"Gordon AD,Hankin PD",A Concurrent Object Calculus: Reduction and Typing,"We obtain a new formalism for concurrent object-oriented languages by extending Abadi and Cardelli's imperative object calculus with operators for concurrency from the π-calculus and with operators for synchronisation based on mutexes. Our syntax of terms is extremely expressive; in a precise sense it unifies notions of expression, process, store, thread, and configuration. We present a chemical-style reduction semantics, and prove it equivalent to a structural operational semantics. We identify a deterministic fragment that is closed under reduction and show that it includes the imperative object calculus. A collection of type systems for object-oriented constructs is at the heart of Abadi and Cardelli's work. We recast one of Abadi and Cardelli's first-order type systems with object types and subtyping in the setting of our calculus and prove subject reduction. Since our syntax of terms includes both stores and running expressions, we avoid the need to separate store typing from typing of expressions. We translate asynchronous communication channels and the choice-free asynchronous π-calculus into our calculus to illustrate its expressiveness; the types of read-only and write-only channels are supertypes of read-write channels.",,,"imperative object calculus based
Abadi/Cardelli based",
"Dhara KK,Leavens GT",Weak Behavioral Subtyping for Types with Mutable Objects,"This paper studies the question of when one abstract data type (ADT) is a behavioral subtype of another, and proposes a model-theoretic notion of weak behavioral subtyping. Weak behavioral subtyping permits supertype abstraction to be a sound and modular reasoning principle in a language with mutation and limited forms of aliasing. The necessary restrictions on aliasing can be statically checked. Weak behavioral subtyping allows types with mutable objects to be subtypes of types with immutable objects.",,model and languge for behavioral subtyping with aliasing,INST,
Fleutot F,Encoding an Object Calculus into Interaction Nets,"We propose an encoding of an object calculus into interaction nets in two stages. First, we make the calculus fully explicit, i.e. with explicit substitutions, duplications and erasures. Then, we use this explicit calculus to produce an interaction net encoding of objects.","Object calculus, Interaction nets, Linearisation, Explicit substitution","object calculi,
ecoding of Fisher-Honsell-Mitchell calculus ito interaction nets",interaction nets,
"Chrząszcz J,Schubert A",Function Definitions for Compound Values in Object-Oriented Languages,"Declarative programming features are gradually included in the design of object-oriented languages such as Java and C++. These languages recently adopted anonymous function definitions and offer basic primitives that restrict changes on data, namely final and const keywords, respectively.We propose a type system for an object-oriented Java-like language that facilitates declarative programming while leaving programmers significant freedom in use of imperative features. The system allows one to delimit compound value representations and effectively define values that are common in functional programming languages. Given that, we distinguish methods that work as first-order functions on such values. In this framework functions may modify internal working state that is clearly separated from the global state of the program. The system exploits access modes for method arguments, which describe the way the method operates on the given entity representation.","extensionality, compound data types, functional programming, object-oriented programming, functions",,Jafun,
T. Jensen; D. Le Metayer; T. Thorn,Security and dynamic class loading in Java: a formalisation,"We give a formal specification of the dynamic loading of classes in the Java Virtual Machine (JVM) and of the visibility of members of the loaded classes. This specification is obtained by identifying the part of the run-time state of the JVM that is relevant for dynamic loading and visibility and consists of a set of inference rules defining abstract operations for loading, linking and verification of classes. The formalisation of visibility includes an axiomatisation of the rules for membership of a class under inheritance, and of accessibility of a member in the presence of accessibility modifiers such as private and protected. The contribution of the formalisation is twofold. First, it provides a clear and concise description of the loading process and the rules for member visibility compared to the informal definitions of the Java language and the JVM. Second, it is sufficiently simple to allow calculations of the effects of load operations in the JVM.",,,Jensen/Le Metayer/Thorn model,
He Jifeng; Liu Zhiming; Li Xiaoshan,Towards a refinement calculus for object systems,"This paper presents a refinement calculus for object systems with visibility, dynamic binding and mutual dependency. The intention is to support effective use of a relational model for specifying and reasoning in activities of an object system development process. The semantics framework will define the meaning of the combinators in the exactly same way as their counterparts in the imperative programming languages. This makes the approach more accessible to the users who are already familiar with the algebraic laws and the verification tools developed for these languages. The paper also provides a set of transformation rules in support of object system refinement.",,,Jifeng/Zhiming/Xiaoshan,
"Hofmann M,Pierce BC",Positive Subtyping,"The statementS⩽Tin aλ-calculus with subtyping is traditionally interpreted by a semantic coercion function of type [[S]]→[lsqb;T]] that extracts the “Tpart” of an element ofS. If the subtyping relation is restricted to covariant positions, this interpretation may be enriched to include both the implicit coercion and an overwriting functionput[S, T]∈[[S]]→[[T]]→[[S]] that updates theTpart of an element ofS. We give a realizability model and a sound equational theory for a second-order calculus of positive subtyping. Though weaker than familiar calculi of bounded quantification, positive subtyping retains 1?sufficient power to model objects, encapsulation, and message passing, and inheritance. The equational laws relating the behavior of coercions andputfunctions can be used to prove simple properties of the resulting ?classes in such a way that proofs for superclasses are “inherited” by subclasses.",,,JML,
"Gheyi R,Borba P",Refactoring Alloy Specifications,"This paper proposes modeling laws for Alloy, a formal object-oriented modeling language. These laws are important not only to define the axiomatic semantics of Alloy but also to guide and formalize popular software development practices. In particular, these laws can be used to formaly refactor specifications. As an example, we formally refactor a specification for Java types.","Formal Methods, Model Transformations, Refactoring, Model Checking",,JML,
R. Piri; S. Mirian-Hosseinabadi,An approach for refining JML specification to object oriented code,"JML is a behavioral interface specification language which has Java as its target implementation language. It combines the idea of using Java expressions from Eiffel language with the model-based approach to specify a program. Refinement calculus is a framework to produce executable code from a specification by preserving the correctness of programs. In this paper some constructs of JML concerning object creation, feature call, exceptional behavior and concurrency constructs are studied and some refinement rules are proposed to obtain an object oriented code in Java from a JML specification containing these constructs. The correctness of these rules is proved by weakest precondition predicate transformer. The refinement of usual constructs in JML such as If-statement, Loop and Assignment from previous works such as Z refinement is also demonstrated.",Formal Methods;Specification;Object Oriented;JML;Refinement Rule;Weakest Precondition,,JML based,
"Fournet C,Laneve C,Maranget L,Rémy D",Inheritance in the join calculus,"We design an extension of the join calculus with class-based inheritance. Method calls, locks, and states are handled in a uniform manner, using asynchronous messages. Classes are partial message definitions that can be combined and transformed by means of operators for behavioral and synchronization inheritance. We also give a polymorphic type system that statically enforces basic safety properties. Our language and its type system are compatible with the JoCaml implementation of the join calculus.","Concurrent objects, Inheritance, Type systems, Polymorphism, Safety properties",,"join calculus
JoCaml PL
pi calculus based",
"Millstein T,Frost C,Ryder J,Warth A",Expressive and Modular Predicate Dispatch for Java,"Predicate dispatch is an object-oriented (OO) language mechanism for determining the method implementation to be invoked upon a message send. With predicate dispatch, each method implementation includes a predicate guard specifying the conditions under which the method should be invoked, and logical implication of predicates determines the method overriding relation. Predicate dispatch naturally unifies and generalizes several common forms of dynamic dispatch, including traditional OO dispatch, multimethod dispatch, and functional-style pattern matching. Unfortunately, prior languages supporting predicate dispatch have had several deficiencies that limit the practical utility of this language feature.We describe JPred, a backward-compatible extension to Java supporting predicate dispatch. While prior languages with predicate dispatch have been extensions to toy or nonmainstream languages, we show how predicate dispatch can be naturally added to a traditional OO language. While prior languages with predicate dispatch have required the whole program to be available for typechecking and compilation, JPred retains Java's modular typechecking and compilation strategies. While prior languages with predicate dispatch have included special-purpose algorithms for reasoning about predicates, JPred employs general-purpose, off-the-shelf decision procedures. As a result, JPred's type system is more flexible, allowing several useful programming idioms that are spuriously rejected by those other languages. After describing the JPred language informally, we present an extension to Featherweight Java that formalizes the language and its modular type system, which we have proven sound. Finally, we discuss two case studies that illustrate the practical utility of JPred, including its use in the detection of several errors.","Predicate dispatch, dynamic dispatch, modular typechecking",,"JPred
Featherweight based",
"Anderson C,Giannini P",Type Checking for JavaScript,"JavaScript is a powerful imperative object based language made popular by its use in web pages. It supports flexible program development by allowing dynamic addition of members to objects. Code is dynamically typed: a runtime access to a non-existing member causes an error. We suggest a static type system for JavaScript that will detect such type errors. Therefore, programmers can benefit from the flexible programming style offered by JavaScript and from the safety offered by a static type system. We demonstrate our type system with a formalism of JavaScript, JS0. Our types are structural. Members of an object type are classified into definite and potential. A potential member becomes definite upon assignment. We outline a proof that our type system is sound.","JavaScript, Scripting Languages, Structural Recursive Types, Type Checking",JS0,JS0 PL,
A. Kupusinac; D. Malbaški,An algorithm for the automatic verification of inheritance,"In this paper we introduce the concept of correct inheritance and establish the appropriate formal conditions that must be satisfied by the subclass. Based on that, we develop a formal recursive algorithm for automatic verification of inheritance. The solution is based solely on the first-order predicate logic.",invariant;inheritance;object-oriented programming;program correctness;program verification,,Kupusinac/Malbaski algorithm,more algorithm than model
T. Studer,A Semantics for λ: a Calculus with Overloading and Late‐binding,"Up to now there was no interpretation available for λ‐calculi featuring overloading and late‐binding, although these are two of the main principles of any object‐oriented programming language. In this paper we provide a new semantics for a stratified version of Castagna's λ<sup>{}</sup>, a λ‐calculus combining overloading with late‐binding. The model‐construction is carried out in EETJ + (Tot) + (<inf>N</inf>F‐I), a system of explicit mathematics. We will prove the soundness of our model with respect to subtyping, type‐checking and reductions. Furthermore, we show that our semantics yields a solution to the problem of loss of information in the context of type‐dependent computations.",Explicit mathematics;typed λ;‐;calculus;overloading; late‐; binding; loss of information,,lambda calculus,
M. Wand,Type inference for record concatenation and multiple inheritance,"The author shows that the type inference problem for a lambda calculus with records, including a record concatenation operator, is decidable. He shows that this calculus does not have principal types but does have finite complete sets of type, that is, for any term M in the calculus, there exists an effectively generable finite set of type schemes such that every typing for M is an instance of one of the schemes in the set. The author shows how a simple model of object-oriented programming, including hidden instance variables and multiple inheritance, may be coded in this calculus. The author concludes that type inference is decidable for object-oriented programs, even with multiple inheritance and classes as first-class values.<<ETX>></ETX>",,,lambda calculus,
J. C. Mitchell; F. Honsell; K. Fisher,A lambda calculus of objects and method specialization,"An untyped lambda calculus, extended with object primitives that reflect the capabilities of so-called delegation-based object-oriented languages, is presented. A type inference system allows static detection of errors, such as message not understood, while at the same time allowing the type of an inherited method to be specialized to the type of the inheriting object. Type soundness, in the form of a subject-reduction theorem, is proved, and examples illustrating the expressiveness of the pure calculus are presented.<<ETX>></ETX>",,,lambda calculus,
"Bono V,Salvo I",A CuCh Interpretation of an Object-Oriented Language1 1Partially supported by MURST Cofin '99 TOSCA,"Böhm's CuCh machine extends the pure lambda-calculus with algebraic data types and provides the possibility of defining functions over disjoint sums of algebras. We exploit such natural form of overloading to define a functional interpretation of a simple, but significant fragment of a typical objectoriented classbased language.",,,lambda calculus based,
"Fairweather E,Fernández M",Typed Nominal Rewriting,"Nominal terms extend first-order terms with nominal features and as such constitute a meta-language for reasoning about the named variables of an object language in the presence of meta-level variables. This article introduces a number of type systems for nominal terms of increasing sophistication and demonstrates their application in the areas of rewriting and equational reasoning. Two simple type systems inspired by Church’s simply typed lambda calculus are presented where only well-typed terms are considered to exist, over which α-equivalence is then axiomatised. The first requires atoms to be strictly annotated whilst the second explores the consequences of a more relaxed de Bruijn-style approach in the presence of atom-capturing substitution. A final type system of richer ML-like polymorphic types is then given in the style of Curry, in which elements of the term language are deemed typeable or not only subsequent to the definition of alpha-equivalence. Principal types are shown to exist and an inference algorithm given to compute them. This system is then used to define two presentations of typed nominal rewriting, one more expressive and one more efficient, the latter also giving rise to a notion of typed nominal equational reasoning.","Nominal syntax, nominal rewriting",,"lambda calculus based
Fairweather/Fernandez model",
"Buchlovsky P,Thielecke H",A Type-theoretic Reconstruction of the Visitor Pattern,"In object-oriented languages, the Visitor pattern can be used to traverse tree-like data structures: a visitor object contains some operations, and the data structure objects allow themselves to be traversed by accepting visitors. In the polymorphic lambda calculus (System F), tree-like data structures can be encoded as polymorphic higher-order functions. In this paper, we reconstruct the Visitor pattern from the polymorphic encoding by way of generics in Java. We sketch how the quantified types in the polymorphic encoding can guide reasoning about visitors in general.","Visitor pattern, polymorphic types, object-oriented programming, Generic Java",,"lambda calculus based
Featherweight based",
"Militão F,Aldrich J,Caires L",Substructural Typestates,"Finding simple, yet expressive, verification techniques to reason about both aliasing and mutable state has been a major challenge for static program verification. One such approach, of practical relevance, is centered around a lightweight typing discipline where types denote abstract object states, known as typestates.In this paper, we show how key typestate concepts can be precisely captured by a substructural type-and-effect system, exploiting ideas from linear and separation logic. Building on this foundation, we show how a small set of primitive concepts can be composed to express high-level idioms such as objects with multiple independent state dimensions, dynamic state tests, and behavior-oriented usage protocols that enforce strong information hiding. By exploring the relationship between two mainstream modularity concepts, state abstraction and hiding, we also provide new insights on how they naturally fit together and complement one another.Technically, our results are based on a typed lambda calculus with mutable references, location-dependent types, and second-order polymorphism. The soundness of our type system is shown through progress and preservation theorems. We also describe a prototype implementation of a type checker for our system, which is available on the web and can be used to experiment with the examples in the paper.","linearity, capabilities, typestate, aliasing",,"lambda calculus based
l3 based",
Castagna G,A meta-language for typed object-oriented languages,"In [12] we defined the λ&-calculus, a simple extension of the typed λ-calculus to model typed object-oriented languages. This paper is the continuation or, rather, the companion of [12] since it analyzes the practical counterpart of the theoretical issues introduced there. Indeed, to develop a formal study of type systems for object-oriented languages we define a meta-language based on λ& and we show, by a practical example, how it can be used to prove properties of a language. To this purpose, we define a toy object-oriented language and its type-checking algorithm; then we translate this toy language into our meta-language. The translation gives the semantics of the toy language and a theorem on the translation of well-typed programs proves the correctness of the type-checker of the toy language. As an aside we also illustrate the expressivity of the λ&-based model by showing how to translate existing features like multiple inheritance and multiple dispatch, but also by integrating in the toy language new features directly suggested by the model, such as first-class messages, a generalization of the use of super and the use of explicit coercions. An important novelty with respect to previous systems is that we show how to model multiple dispatch also in the presence of a notion of receiver (i.e. of a privileged argument to which the message is passed), a notion that is absent in languages like CLOS.",,,"lambda calculus based
lambda & calculus",
"Bono V,Bugliesi M",Matching for the lambda calculus of objects,"A relation between recursive object types, called matching, has been proposed [8] to provide an adequate typing of inheritance in class-based languages. This paper investigates the role of this relation in the design of a type system for the Lambda Calculus of Objects [15]. A new type system for this calculus is defined that uses implicit matchbounded quantification over type variables instead of implicit quantification over row schemes — as in [15] — to capture MyType polymorphic types for methods. An operational semantics is defined for the untyped calculus and type soundness for the new system is proved as a corollary of a subject reduction property. A formal analysis of the relative expressive power of the two systems is also carried out, that explains how the row schemes of [15] can be understood in terms of matching, and shows that the new system is as powerful as the original one on derivations of typing judgements for closed objects.","Object calculi, Object extension, specialization, Matching",,"Lambda calculus of objects
lambda calculus based",
Abel A,A Third-Order Representation of the λμ-Calculus,"Higher-order logical frameworks provide a powerful technology to reason about object languages with binders. This will be demonstrated for the case of the λμ-calculus with two different binders which can most elegantly be represented using a third-order constant. Since cases of third- and higher-order encodings are very rare in comparison with those of second order, a second-order representation is given as well and equivalence to the third-order representation is proven formally.",,λμ-calculus,"lambda mu calculus
lambda calculus based",
Padgham L,Defeasible inheritance: A lattice based approach,"We describe here a model for inheritance reasoning based on the notion that a type can be described by two basic sets of characteristics—those that are necessary for the type and those that are typical for the type. All possible combinations of characteristics form a boolean lattice in which type descriptors can be placed relative to one another. Common lattice properties (such as transitivity of ]) combined with a default assumption operation form the basis for a theory of defeasible reasoning in inheritance networks. This paper gives a careful, but informal overview of the model, with several examples and many diagrams. For a more formal treatment, the interested reader is referred to the final chapters of [1]. The model allows a natural representation and a clean reasoning mechanism, at the same time as it adequately captures many of our intuitions regarding conclusions. It is also able to express some interesting nuances which are not available in other theories.",,"lattice
types",lattice based approach,not oop
"Leavens GT,Naumann DA","Behavioral Subtyping, Specification Inheritance, and Modular Reasoning","Verification of a dynamically dispatched method call, E.m(), seems to depend on E’s dynamic type. To avoid case analysis and allow incremental development, object-oriented program verification uses supertype abstraction. In other words, one reasons about E.m() using m’s specification for E’s static type. Supertype abstraction is valid when each subtype in the program is a behavioral subtype. This article semantically formalizes supertype abstraction and behavioral subtyping for a Java-like sequential language with mutation and proves that behavioral subtyping is both necessary and sufficient for the validity of supertype abstraction. Specification inheritance, as in JML, is also formalized and proved to entail behavioral subtyping.","specification inheritance, verification, predicate transformer, dynamic dispatch, refinement, Eiffel language, supertype abstraction, JML language, Behavioral subtyping, state transformer, modularity, specification",,Leavens/Nauman model and pl,
"Buchanan M,Britton C",Formal specification and object-oriented design,"In recent years, object-oriented design and formal specification languages have become increasingly important in the development of software systems. In this paper we use the formal specification languages OBJ1 and OBJ3 to investigate the extent to which they support object-oriented design in general and inheritance in particular.","Formal Specification, Inheritance, OBJ",,LePUS FL,
Z. Luo,Coercive subtyping,"We propose and study coercive subtyping, a formal extension with subtyping of dependent type theories such as Martin-Löf's type theory and the type theory UTT. In this approach, subtyping with specified implicit coercions is treated as a feature at the level of the logical framework; in particular, the meaning of an object being in a supertype is given by coercive definition rules for the definitional equality. This provides a conceptually simple and uniform framework to understand subtyping and inheritance relations in type thoeries with sophisticated type structures such as inductive types and universes. The use of coercive subtyping in formal development and in reasoning about subsets of objects is discussed in the context of computer-assisted formal reasoning.",Type theory;subypting;coercion;formal reasoning;logical framework,"dependent types
Marti-Lof
UUT","LF
logical framework",
"Levine KM,Masters P",SYMBOLIC INFORMATION PROCESSING,"Publisher Summary Symbolic information processing is born of looking at problems in an algebraic, rather than arithmetic, manner. The process of abstraction, from object to symbol, underlies every theoretical model of computation. The Turing machine paradigm is not the only one. Other equally valid formalisms exist; some exhibit more algebraic behavior than others. Although literally isomorphic to Turing's machine, Church's λ calculus is aesthetically of a different nature. The aesthetics make a difference, because the human mind can comprehend very little of the content of a large computer program. This chapter presents the analysis of an algorithm that differentiates polynomials. The traditional solution of the business data processing problem has been the human wave handwritten COBOL program. The economic considerations dictate that in these times of ever-increasing hardware capability per dollar, a more automated solution be found. A solution can be found in the form of a somewhat smart computer program—LINDA.",,"abstract machines
lambda-calculus
cobol
linda",Linda,no source
M. Bugliesi; G. Delzanno; L. Liquori; M. Martelli,Object calculi in linear logic,"Several calculi of objects have been studied in the recent literature, that support the central features of object-based languages: messages, inheritance, dynamic dispatch, object update and object-extension. We show that a complete semantic account of these features may be given in a fragment of higher-order linear logic.",Object calculi;linear logic;logic programming,O_o,linear logic,
M. Maher,A Linear Logic Calculus of Objects,"This paper presents a linear logic programming language, called O⊸ that gives a complete account of an object-oriented calculus with inheritance and override. This language is best understood as a. logical counterpart the object and record extensions of functional programming that have recently been proposed in the literature. From these proposals, O⊸ inherits the representation of objects as composite data structures, with attribute and method fields, as well as their interpretation as first-class values. O⊸ also gives a direct logical modeling of the self-application semantics of method invocation that justifies the view of objects as elements of recursive types. As such, the design of O⊸ appears interesting, in perspective, as a basis for developing flexible and powerful type systems for logical object-based languages.",,O_o,linear logic,
Zhi Jin,An order-based composition semantics for the inheritance in logic-based object-oriented paradigm,"Inheritance is an important concept in the object-oriented paradigm, but its semantics is far from being well-defined. This paper focuses on inheritance with overriding. First, an elegant approach is proposed for combining the logical style with the object-oriented paradigm. In this language model, inheritance is modelled by an order-based composition of the logic objects. Overriding is given a formal treatment by introducing the so-called hiding operator. Finally, a corresponding model composition with hiding is also presented.",,Lobject,"Lobject Model
algebraic language",
"Luo C,Qin S",Separation Logic for Multiple Inheritance,"As an extension to Floyd-Hoare logic, separation logic has been used to facilitate reasoning about imperative programs manipulating shared mutable data structures. Recently, it has also been extended to support modular reasoning in Java-like object-oriented languages where only single inheritance is allowed. In this paper we propose an extension of separation logic to support also the reasoning for multiple inheritance in C++ -like languages. To cater for multiple inheritance, we modified the standard storage model for separation logic in a way that the correct reference to a field or a method can be easily determined. On top of this storage model, a set of proof rules are proposed. Our verification system also provides basic support for behavioral subtyping.","Multiple Inheritance, Separation Logic, Verification",,"Luo/Qin model
separation logic based
C++ based",
"Maidl AM,Carvilhe C,Musicante MA",Maude Object-Oriented Action Tool,"Object-Oriented Action Semantics (OOAS) incorporates object-oriented concepts to the Action Semantics formalism. Its main goal is to obtain more readable and reusable semantics specifications. Moreover, it supports syntax-independent specifications, due to the way classes are written. Maude Object-Oriented Action Tool (MOOAT) is an executable environment for Object-Oriented Action Semantics implemented as a conservative extension of Full Maude and Maude MSOS Tool (MMT). The Modular SOS of Action Notation has been implemented using MMT transitions and Full Maude has been used to implement the Classes Notation. The syntax created by MOOAT is fairly similar to the original Object-Oriented Action Semantics syntax. In addition to it, the tool combines the modularity aspects observed in the object-oriented approach with the efficient execution and analysis of the Maude system. We use MOOAT to describe syntax-independent specifications of programming languages. In this way, we show how Constructive Object-Oriented Action Semantics (COOAS) may be achieved as a combination between Object-Oriented Action Semantics and Constructive Action Semantics (CAS) using MOOAT, in order to increase the modularity aspects observed in the object-oriented formalism. This paper reports on the development of Maude Object-Oriented Action Tool and its application to the formal specification of programming languages.","Constructive Action Semantics, Formal Semantics, Maude, Modular Structural Operational Semantics, Object-Oriented Action Semantics",,Maude,
"Clavel M,Eker S,Lincoln P,Meseguer J",Principles of Maude,"This paper introduces the basic concepts of the rewriting logic language Maude and discusses its implementation. Maude is a wide-spectrum language supporting formal specification, rapid prototyping, and parallel programming. Maude's rewriting logic paradigm includes the functional and object-oriented paradigms as sublanguages. The fact that rewriting logic is reflective leads to novel metaprogramming capabilities that can greatly increase software reusability and adaptability. Control of the rewriting computation is achieved through internal strategy languages defined inside the logic. Maude's rewrite engine is designed with the explicit goal of being highly extensible and of supporting rapid prototyping and formal methods applications, but its semi-compilation techniques allow it to meet those goals with good performance.",,Maude,Maude Prover,
S. Denier; Y. Guéhéneuc,"Mendel: A Model, Metrics, and Rules to Understand Class Hierarchies","Inheritance is an important mechanism when developing object-oriented programs with class-based programming languages: it enables subtyping, polymorphism, and code reuse. Inheritance is also known as a difficult feature to grasp and to use correctly because of its many purposes. We propose a model of inheritance to help understand class hierarchies of class-based object-oriented programs. We define metrics and rules to highlight interesting classes and behaviours with respect to inheritance. Thus, we provide the programmer with insight on how inheritance is used in a program. We illustrate our approach on JHOTDraw and validate it further on three other programs: ArgoUML, Azureus, and Log4J. We also show that our model can describe existing rules, such as micro patterns.",object oriented;inheritance;class hierarchy;reverse engineering;metrics;comprehension,Mendel,Mendel Model,
I. Merlo; E. Bertino; E. Ferrari; G. Guerrini,A temporal object-oriented data model with multiple granularities,"We investigate some issues arising from the introduction of multiple temporal granularities in an object-oriented data model. Although issues concerning temporal granularities have been investigated in the context of temporal relational database systems, no comparable amount of work has been done in the context of object-oriented models. Moreover, the main drawback of the existing proposals is the lack of a formal basis-which we believe is essential to manage the inherent complexity of the object-oriented data model. We provide a complete temporal object-oriented type system supporting multiple temporal granularities and we formally define the set of legal values for our type system. We then address issues related to inheritance, type refinement and substitutability.",,,Merlo/Bertino/Ferrari/Guerrini temporal type system,temporal
"Middelkoop R,Huizing C,Kuiper R,Luit EJ",Invariants for Non-Hierarchical Object Structures,"We present a Hoare-style specification and verification approach for invariants in sequential OO programs. It allows invariants over non-hierarchical object structures, in which update patterns that span several objects and methods occur frequently. This gives rise to invalidating and subsequent re-establishing of invariants in a way that compromises standard data induction, which assumes invariants hold when a method is called. We provide specification constructs (inc and coop) that identify objects and methods involved in such patterns, allowing a refined form of data induction. The approach now handles practical designs, as illustrated by a specification of the Observer Pattern.","Invariants, Formal specification, Program verification, Object-oriented programs",,Middelkoop/Huizing/Kuiper/Luit/ model,
Kuno Y,Misty: An Object-Oriented Programming Language with Multiple Inheritance and Strict Type-Checking,"Summary A strong type-checking facility is indispensable for an object-oriented programming language to be usable in large-scale software development. Misty is an object-oriented programming language with both multiple inheritance and strict type-checking facilities. Type-checking is applied not according to subtype relations between types, but according to strict equality between types. This principle differs markedly from that of other object-oriented programming languages with “strong” type-checking facilities, which incorporate subtype relations, and Misty's type-checking facility therefore termed a “strict” one. In spite of this strictness, Misty retains most of the flexibility seen in object-oriented programming languages without compile-time type checking. Moreover, experience of programming in Misty has revealed that program design and development using a class specification hierarchy along with a compiler to check its consistency will be a valuable and powerful tool for programming-in-the-large.",,,"Misty
PL",
Milner R,A theory of type polymorphism in programming,"The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.",,"polymorhic,
type discipline","ML
metalanguage",
"Fisher K,Reppy J",Inheritance-Based Subtyping,"Classes play a dual role in mainstream statically typed object-oriented languages, serving as both object generators and object types. In such languages, inheritance implies subtyping. In contrast, the theoretical language community has viewed this linkage as a mistake and has focused on subtyping relationships determined by the structure of object types, without regard to their underlying implementations. In this paper, we explore why inheritance-based subtyping relations are useful, and we describe two different approaches to extending the MOBY programming language with inheritance-based subtyping relations. In addition, we present a typed object calculus that supports both structural and inheritance-based subtyping, and which provides a formal accounting of our extensions to MOBY.",,,Moby PL,
P. A. Patsouris,A formal versioning approach for distributed objectbases,"We initially provide, in summary, a formal object-oriented model for objectbases considering (i) simple objects (classes and their instances), (ii) 2-objects (2-classes and their 2-instances) where each 2-object encapsulates a two-level-hierarchy of objects, and (iii) complex objects defined inductively from the 2-objects through a composition operation. The inheritance concept is replaced by that of a ""link"" between two objects. Based on the above model, we introduce and develop a formal versioning approach by defining the concepts of ""core data"" and ""core behaviour"" that together are expressed through the term ""compatibility"" among objects. We extend the ""versioning"" notion to encompass not only the instances but also the classes, and 2-classes of our formal object-oriented model and include the different ""views"" (modelled as objects) of an entity within the same versioning framework. We further refer to the appropriate versioning structures. We then develop a distribution strategy encompassing 2-objects and complex objects, as well as their versions, and stress the advantages (both at the design and distribution level) of this approach through an example.",,objectbases,Model,
"Buro S,Crole R,Mastroeni I",Equational Logic and Categorical Semantics for Multi-Languages,"Programming language interoperability is the capability of two programming languages to interact as parts of a single system. Each language may be optimized for specific tasks, and a programmer can take advantage of this. HTML, CSS, and JavaScript yield a form of interoperability, working in conjunction to render webpages. Some object oriented languages have interoperability via a virtual machine host (.NET CLI compliant languages in the Common Language Runtime, and JVM compliant languages in the Java Virtual Machine). A high-level language can interact with a lower level one (Apple's Swift and Objective-C). While there has been some research exploring the interoperability mechanisms (Section 1) there is little development of theoretical foundations. This paper presents an approach to interoperability based around theories of equational logic, and categorical semantics. We give ways in which two languages can be blended, and interoperability reasoned about using equations over the blended language. Formally, multi-language equational logic is defined within which one may deduce valid equations starting from a collection of axioms that postulate properties of the combined language. Thus we have the notion of a multi-language theory and much of the paper is devoted to exploring the properties of these theories. This is accomplished by way of category theory, giving us a very general and flexible semantics, and hence a nice collection of models. Classifying categories are constructed, and hence equational theories furnish each categorical model with an internal language; from this we can also establish soundness and completeness. A set-theoretic semantics follows as an instance, itself sound and complete. The categorical semantics is based on some pre-existing research, but we give a presentation that we feel is easier and simpler to work with, improves and mildly extends current research, and in particular is well suited to computer scientists. Throughout the paper we prove some interesting properties of the new semantic machinery. We provide a small running example throughout the paper to illustrate our ideas, and a more complex example in conclusion.","categorical logic, equational logic, interoperability, multi-languages, order-sorted signatures and theories, programming languages, subsort polymorphism",categorical semantics,"model
cateforical semantics for multilagugaes",
"Djang RW,Burnett MM,Chen RD",Static Type Inference for a First-Order Declarative Visual Programming Language with Inheritance,"The early detection of type errors is a well-known benefit of static typing, but until recent years, this benefit usually has come at the cost of requiring the programmer to explicitly declare the type of every object in a program. Since many visual programming languages (VPLs), especially those VPLs intended for end users, are designed to eliminate such programming mechanisms, most VPLs have been implemented with dynamic typing, thereby sacrificing early type error feedback and other benefits of static typing. One potential solution for this dilemma is static type inference, but unfortunately, the types inferred under previous approaches have been notoriously difficult to understand, even for professional programmers. Compounding this problem is the fact that when support for inheritance is added to such type inference systems, explicit type declarations have re-emerged. In this paper, we present a model of types that supports static type inference for a declarative VPL that includes inheritance. Our model addresses the problems presented in the previous paragraph. We present the formal model of our type system, and show that the model is not only sound with respect to type safety, but that it also has sufficient power to support traditional and non-traditional forms of inheritance, and further that it requires the user to understand only a small vocabulary of types, a feature important in addressing the understandability problem in end-user VPLs.",,static type inference foe visual programming language,"model 
for Visual Programming Laguages",
"Broman D,Siek JG",Gradually Typed Symbolic Expressions,"Embedding a domain-specific language (DSL) in a general purpose host language is an efficient way to develop a new DSL. Various kinds of languages and paradigms can be used as host languages, including object-oriented, functional, statically typed, and dynamically typed variants, all having their pros and cons. For deep embedding, statically typed languages enable early checking and potentially good DSL error messages, instead of reporting runtime errors. Dynamically typed languages, on the other hand, enable flexible transformations, thus avoiding extensive boilerplate code. In this paper, we introduce the concept of gradually typed symbolic expressions that mix static and dynamic typing for symbolic data. The key idea is to combine the strengths of dynamic and static typing in the context of deep embedding of DSLs. We define a gradually typed calculus λ, formalize its type system and dynamic semantics, and prove type safety. We introduce a host language called Modelyze that is based on λ, and evaluate the approach by embedding a series of equation-based domain-specific modeling languages, all within the domain of physical modeling and simulation.","DSL, Type systems, Symbolic expressions",,"Modelyze based
grafually typing based
lambda calculus based",
"Amrani M,Schobbens PY",Formal Analysis of Object-Oriented Mograms,"A mogram designates a software language implemented in either a programming or a modelling language. Object-Oriented mograms share many common language features, but also have specificities related to inheritance, collection values, opposite and contained references, or overloading. We propose a mathematical framework that captures the semantics of such mograms with a precise characterisation of the variation points. We implemented a prototype tool that enables formal analysis in a uniform way.","Formal Verification, OO Languages, Semantics",,mogram based,
"Dezani-Ciancaglini M,Drossopoulou S,Mostrous D,Yoshida N",Objects and session types,"A session takes place between two parties; after establishing a connection, each party interleaves local computations and communications (sending or receiving) with the other. Session types characterise such sessions in terms of the types of values communicated and the shape of protocols, and have been developed for the π-calculus, CORBA interfaces, and functional languages. We study the incorporation of session types into object-oriented languages through MOOSE, a multi-threaded language with session types, thread spawning, iterative, and higher-order sessions. Our design aims to consistently integrate the object-oriented programming style and sessions, and to be able to treat various case studies from the literature. We describe the design of MOOSE, its syntax, operational semantics, and type system, and develop a type inference system. After proving subject reduction, we establish the progress property: once a communication has been established, well-typed programs will never starve at communication points.",,,"Moose
pi calculus based",
Charatan Q,MOOV++: modular object-oriented VDM,"This paper describes MOOV++, a methodology for formal object-oriented development. MOOV++ takes as its starting point an object-oriented specification, which is subsequently developed by means of an existing and well-established formal method, the Vienna Development Method (VDM). MOOV++ utilises the VDM module notation to represent a class; the paper demonstrates how all the important concepts, which together define Object-Orientation can be captured formally in VDM. It also provides a proof obligation by which the behaviour of an inherited class can be proved to be consistent with its base class.","Object-oriented development, Formal methods, Vienna development method",,"MOOV++
VDM based",
de Boer FS,A shared-variable concurrency analysis of multi-threaded object-oriented programs,In this paper a proof outline logic is introduced for the partial correctness of multi-threaded object-oriented programs like in Java. The main contribution is a generalization of the Owicki& Gries proof method for shared-variable concurrency to dynamic thread creation. This paper also provides a formal justification of this generalization in terms of soundness and completeness proofs.,"Verification, Partial correctness, Multi-threaded object-oriented programs interference, Soundness, Completeness",,"MT
abstract core languge
proof outline based",
Li XuanDong; Zheng GuoLiang,A modified inheritance mechanism enhancing reusability and maintainability in object-oriented languages,"In object-oriented languages, encapsulation and inheritance play an important part for software reusability and maintainability. The separation of subtyping and inheritance makes inheritance a more flexible mechanism reusing code. The main enhanced flexibility is that it is allowed for subclasses to redefine inherited methods to change their specifications. However, it results in an encapsulation issue derived from the semantics of inheritance, which compromises severely reusability and maintainability in object-oriented languages. The authors present a modified inheritance mechanism which overcomes this encapsulation issue, and give its denotational semantics. This modified inheritance mechanism has been introduced in NDOOP, an object-oriented extension of Pascal bing developed by them.",,"o-o pascal
inheritance mechanism, smalltalk",NDOOP,
A. Gacek; D. Miller; G. Nadathur,Combining Generic Judgments with Recursive Definitions,"Many semantical aspects of programming languages, such as their operational semantics and their type assignment calculi, are specified by describing appropriate proof systems. Recent research has identified two proof-theoretic features that allow direct, logic-based reasoning about such descriptions: the treatment of atomic judgments as fixed points (recursive definitions) and an encoding of binding constructs via generic judgments. However, the logics encompassing these two features have thus far treated them orthogonally: that is, they do not provide the ability to define object-logic properties that themselves depend on an intrinsic treatment of binding. We propose a new and simple integration of these features within an intuitionistic logic enhanced with induction over natural numbers and we show that the resulting logic is consistent. The pivotal benefit of the integration is that it allows recursive definitions to not just encode simple, traditional forms of atomic judgments but also to capture generic properties pertaining to such judgments. The usefulness of this logic is illustrated by showing how it can provide elegant treatments of object-logic contexts that appear in proofs involving typing calculi and of arbitrarily cascading substitutions that play a role in reducibility arguments.",generic judgments;higher-order abstract syntax;proof search;reasoning about operational semantics,,Nkthm,
AbdelGawad MA,A Domain-Theoretic Model Of Nominally-Typed Object-Oriented Programming,"The majority of contemporary mainstream object-oriented (OO) software is written using nominally-typed OO programming languages. Extant domain-theoretic models of OOP developed to analyze OO type systems miss crucial features of these mainstream OO languages, such as nominality. This paper summarizes the construction of NOOP as a domain-theoretic model of OOP that includes nominal information found in nominally-typed mainstream OO software. Inclusion of nominal type information and asserting that type inheritance in statically-typed OO programming languages is an inherently nominal notion allow readily proving that inheritance and subtyping are completely identified in these languages. This conclusion is in full agreement with intuitions of OO developers using these languages, and contrary to the belief that “inheritance is not subtyping”, which came from assuming non-nominal structural models of OO type systems. NOOP, thus, provides a firmer semantic foundation for analyzing and progressing nominally-typed mainstream OO programming languages.","Object-Oriented Programming, Denotational Semantics, Nominative Type Systems, Structural Type Systems, , Type Names, Inheritance, Subtyping, OOP, Java, C#",,NOOP model,
S. A. DeLoach; T. C. Hartrum,A theory-based representation for object-oriented domain models,"Formal software specification has long been touted as a way to increase the quality and reliability of software; however, it remains an intricate, manually intensive activity. An alternative to using formal specifications directly is to translate graphically based, semiformal specifications into formal specifications. However, before this translation can take place, a formal definition of basic object oriented concepts must be found. The paper presents an algebraic model of object orientation that defines how object oriented concepts can be represented algebraically using an object oriented algebraic specification language O-SLANG. O-SLANG combines basic algebraic specification constructs with category theory operations to capture internal object class structure, as well as relationships between classes.",,O-SLANG,"O-SLANG Model
algebraic language",
R. Viswanathan,Full abstraction for first-order objects with recursive types and subtyping,"We present a new interpretation of typed object-oriented concepts in terms of well-understood, purely procedural concepts, that preserves observational equivalence. More precisely, we give compositional translations of (a) Ob/sub 1/spl mu//, an object calculus supporting method invocation and functional method update with first-order object types and recursive types, and (b) Ob/sub 1<:/spl mu//, an extension of Ob/sub 1/spl mu// with subtyping, that are fully abstract on closed terms. The target of the translations are a first-order /spl lambda/-calculus with records and recursive types, with and without subtyping. The translation of the calculus with subtyping is subtype-preserving as well.",,"object calculus
types
subtyping","Ob1 based
Abadi/Cardelli based",
"Aceto L,Hüttel H,Ingólfsdóttir A,Kleist J",Relating Semantic Models for the Object Calculus: Preliminary Report,"Abadi and Cardelli have investigated several versions of the ç-calculus, a calculus for describing central features of object-oriented programs, with particular emphasis on various type systems. In this paper we study the properties of a denotational semantics due to Abadi and Cardelli vis-à-vis the notion of observational congruence for the calculus Ob1<:μ. In particular, we prove that the denotational semantics based on partial equivalence relations is correct with respect to observational congruence. By means of a counter-example, we argue that the denotational model is not fully abstract with respect to observational congruence. In fact, the model is able to distinguish objects that have the same behaviour in every Ob1<:μ-context.",,,"Ob1 based
Abadi/Cardelli based",
"Glimming J,Ghani N",Difunctorial Semantics of Object Calculus,"In this paper we give a denotational model for Abadi and Cardelli's first order object calculus FOb1+×μ (without subtyping) in the category pCpo. The key novelty of our model is its extensive use of recursively defined types, supporting self-application, to model objects. At a technical level, this entails using some sophisticated techniques such as Freyd's algebraic compactness to guarantee the existence of the denotations of the object types. The last sections of the paper demonstrates that the canonical recursion operator inherent in our semantics is potentially useful in object-oriented programming. This is witnessed by giving a straightforward translation of algebraic datatypes into so called wrapper classes.","Category theory, object-oriented programming",,"Ob1 based
Abadi/Cardelli based",
S. W. Clyde; D. W. Embley; S. N. Woodfield,Improving the quality of systems and domain analysis through object class congruency,"A new concept for assessing the quality of object classes in analysis models, called object-class congruency, is formally defined and discussed. Object-class congruency is based on the idea that immediate and inherited properties defined for an object class should match the common properties of the class's members. A semantic model with a formal definition is used to formalize these concepts. In addition to defining object-class congruency, two semantic-preserving transformations that convert incongruent classes into congruent classes are given. It is also explained why object-class congruency leads to better abstraction of real-world concepts and to better implementation, extension, and reuse.",,,object class congruency,
"Dotti FL,Duarte LM,Foss L,Ribeiro L,Russi D,dos Santos OM",An Environment for the Development of Concurrent Object-Based Applications,"Object-Based Graph Grammars (OBGG) is a formal specification language suitable for modeling concurrent object-based systems. On previous work we have mainly discussed the language along with case studies and analysis techniques (model checking and simulation) for systems described in OBGG. In this paper we present the set of tools we have developed and/or integrated to build an environment for the development of concurrent object-based systems. With this environment, we support the specification and analysis of concurrent object-based systems specified using OBGG.","Edition, verification, simulation, code generation","OBGG,
concurrency",Object-Based Graph Grammars,
"Liu X,Walker D",Partial confluence of processes and systems of objects,"A process calculus extending the π-calculus with higher-order agent abstractions as in the Higher-Order π-calculus and first-order data other than names but with only first-order interaction is used to give a natural and direct semantic definition for a concurrent object-oriented programming language. A notion of partial confluence of agents is introduced and its theory developed, first in the setting of CCS and then in the mobile-process calculus. It is shown how the semantic definition can be used as a basis for reasoning about systems prescribed by programs of the language: the theory of partial confluence is used to prove the indistinguishability in an arbitrary program context of two classes whose instances combine to form data structures only one of which supports concurrent operations.",,,Object-Z,
"Golubski W,Lippe WM",A complete semantics for SMALLTALK-80,"In this paper we introduce a formal model of the object-oriented programming language SMALLTALK-80. The model can be useful for different applications in the framework of language design and implementation like compiter or interpreter generation, correctness proofs of the implementations, and standardization of the language.","object-oriented programming languages, SMALLTALK-80, formal model, operational semantics, denotational semantics",,Object-Z,
"Lee JH,Pun PK",Object logic integration: A multiparadigm design methodology and a programming language,"In the past decade, there has been much research effort dedicated to combine the object-oriented programming paradigm and the logic programming paradigm. Most of this effort sheds light upon the philosophy of multiparadigm programming as a near ideal mental model for a wide class of problem domains. In this paper we propose a scheme for object and logic integration—the OLI scheme. This scheme contributes to the multiparadigm programming philosophy by putting forward a multiparadigm design methodology and describing a multiparadigm programming language. Above all, the OLI scheme integrates the object-oriented and the logic programming paradigms at the design and language levels with a precise and well-balanced interface so that each paradigm shares an equal and cooperating partnership in problem analysis and problem solving. An important property of the OLI language is that programmers can program either in one of the paradigms alone or in a mixed paradigm without sacrificing expressiveness and efficiency. We give a formal definition of the OLI language and study its semantics both from the logical perspective and the object-oriented perspective. By viewing objects as an enrichment of the Herbrand universe, we define the declarative and operational semantics of OLI. We show that OLI's operational semantics, a generalized form of SLD-resolution, is sound and complete. From the object-oriented point of view, the logic part of OLI is simply an object with logic programs as states and methods for performing logical deduction.","multiparadigm programming languages, logic programming, object-oriented programming",,Object-Z,
"Igarashi A,Pierce BC",Foundations for Virtual Types,"Virtual types have been proposed as a notation for generic programming in object-oriented languages—an alternative to the more familiar mechanism of parametric classes. The trade-offs between the two mechanisms are a matter of current debate: for many examples, both appear to offer convenient (indeed almost interchangeable) solutions; in other situations, one or the other seems to be more satisfactory. However, it has proved difficult to draw rigorous comparisons between the two approaches, partly because current proposals for virtual types vary considerably in their details, and partly because the proposals themselves are described rather informally, usually in the complicating context of full-scale language designs. Work on the foundations of object-oriented languages has already established a clear connection between parametric classes and the polymorphic functions found in familiar typed lambda-calculi. Our aim here is to explore a similar connection between virtual types and dependent records. We present, by means of examples, a straightforward model of objects with embedded type fields in a typed lambda-calculus with subtyping, type operators, fixed points, dependent functions, and dependent records with both bounded and manifest type fields (this combination of features can be viewed as a measure of the inherent complexity of virtual types). Using this model, we then discuss some of the major differences between previous proposals and show why some can be checked statically while others require run-time checks. We also investigate how the partial “duality” of virtual types and parametric classes can be understood in terms of translations between universal and (dependent) existential types.",,,Object-Z,
"Duke R,Rose G,Smith G",Object-Z: A specification language advocated for the description of standards,"The importance of formalising the specification of standards has been recognised for a number of years. This paper advocates the use of the formal specification language Object-Z in the definition of standards. Object-Z is an extension to the Z language specifically to facilitate specification in an object-oriented style. First, the syntax and semantics of Object-Z are described informally. Then the use of Object-Z in formalising standards is demonstrated by presenting a case study based on the ODP Trader. Finally, a formal semantics is introduced that suggests an approach to the standardisation of Object-Z itself. Because standards are typically large complex systems, the extra structuring afforded by the Object-Z class construct and operation expressions enables the various hierarchical relationships and the communication between objects in a system to be succinctly specified.","Object-orientation, Formal specification, Formal semantics, Standards",,Object-Z,
"Leavens GT,Pigozzi D",Class-Based and Algebraic Models of Objects,"We compare different kinds of first-order models of objects and message passing, as found in object-oriented programming languages. We show that generic function models can easily simulate record models for static, class-based languages. We explore type systems for such languages, and show that our simulation preserves typing. Algebraic models emerge as abstractions of the generic function model that suppress details that are irrelevant for client code. Thanks to Todd Millstein for comments on an earlier draft, and for suggesting that we make our comparisons between the record and generic function models constructive, which greatly improved the paper. Thanks to Todd and Craig Chambers for many discussions about multimethod languages and their type systems.",,,Object-Z,
Kurz A,Specifying coalgebras with modal logic,"We propose to use modal logic as a logic for coalgebras and discuss it in view of the work done on coalgebras as a semantics of object-oriented programming. Two approaches are taken: First, standard concepts of modal logic are applied to coalgebras. For a certain kind of functor it is shown that the logic exactly captures the notion of bisimulation and a complete calculus is given. Examples of verifications of object properties are given. Second, we discuss the relationship of this approach with the coalgebraic logic of Moss (Coalgebraic logic, Ann Pure Appl. Logic 96 (1999) 277–317.).","Coalgebras, Modal logic, Object-oriented programming, Verification, Specification",,Object-Z,
"Krause PJ,Byers PJ,Hajnal S",Formal specification and decision support,"To gain widespread acceptance, decision support systems must be built to the highest possible standards. We believe techniques of formal specification and refinement have a valuable role to play in the development of certain components of decision support systems. We present a tutorial study of the use of formal specification focused on a system for maintaining deductive extensions of a knowledge base. The system is specified using an object-oriented variant of the specification language Z. The relationship of the formal specification with existing theoretical work in AI is discussed together with its refinement into a demonstrably correct implementation.","DSS development, Formal specification, Software engineering, KBS validation",,Object-Z,
K. Periyasarny,Object-oriented formal specifications,"Recent developments in research on formal methods made formal specification languages to be widely used in industrial applications. In particular, formal specification languages are mainly used to understand and/or to analyze requirements of software systems, though they can be used at all stages of software development. When combined with object-oriented approach, formal specification languages have cumulative advantages such as analyzing properties of objects in isolation and supporting reusability. In this tutorial, I describe the object-oriented formal specification language Object-Z and how it can be used to capture requirements of a software system. Object-Z is an object-oriented extension of the formal specification language Z.",,,Object-Z,
T. Waheed; M. U. Khan; A. Nadeem,Polymorphic Extensions to Object-Z Specifications,"Inheritance and polymorphism are powerful constructs of object-oriented paradigm, which are supported by almost all object-oriented programming languages. However, majority of existing formal specification languages lack concrete support for polymorphism. For this reason, we propose polymorphic extensions to object-Z, a formal specification language commonly used for object-oriented systems, by defining several novel notations specific to polymorphism. We also define a schema policy that determines the actual late binding of the object with the corresponding reference. We then demonstrate the usability of these extensions by applying them on an example",,,Object-Z,
D. K. C. Chan; D. J. Harper; P. Trinder,An object-oriented data model specification,"This paper presents a formal specification of an object-oriented data model using the Z specification language. The model supports all the essential features found in existing object-oriented data models. More importantly it simultaneously supports multiple inheritance, method overloading together with static type-checking. Formal specification not only helps to overcome the ambiguity problems found in less formal approaches it also allows one to reason about the properties of the model. This specification demonstrates the use of Z as a formal technique in an area where such a definition is greatly needed.<<ETX>></ETX>",,,Object-Z,
A. Griffiths,"""self""-conscious objects in Object-Z","Within the field of object oriented type theory, much attention has been devoted to the notion of self and Self-types. In contrast, relatively little attention has been paid to this topic in studies on object oriented specification language semantics. In the context of language semantics, the notion of self poses two problems. Firstly, it involves an awareness by an object of its own identity, and hence a capacity for self referential method invocations. Secondly, the usual reference model for object identity maps object identities to object values. This means that an object's identity is not normally considered to be a part of its value. And so a value for self is not normally in scope. The way that a semantics resolves the scope problem can affect one's ability to use the semantics to reason about an object independently of its environment. The paper motivates the inclusion of a concept of self in object oriented formal specification languages, and shows how this concept can be accommodated within the semantics of Object-Z. We show that a useful consequence of making objects 'self'-aware is that messages between objects can be 'tagged' with the identity of the sender object; this facilitates the task of reasoning about object interaction.",,,Object-Z,
G. Smith; S. Helke,Refactoring Object-Oriented Specifications with Inheritance-Based Polymorphism,"Specification notations such as JML and Spec# which are embedded into program code provide a promising approach to formal object-oriented software development. If the program code is refactored, however, the specifications need also to be changed. This can be facilitated by specification refactoring rules which allows such changes to be made systematically along with the changes to the code. A set of minimal and complete set of refactoring rules have been devised for the Object-Z specification language. This paper reviews these rules as a basis for a similar approach for languages like JML and Spec#. Specifically, it modifies the rules for introducing and removing inheritance and polymorphism from specifications. While these concepts are orthogonal in Object-Z, they are closely intertwined in the other notations.",object-oriented refactoring;object-z,,object-z based,
M. Fukagawa; T. Hikita; H. Yamazaki,A mapping system from Object-Z to C++,"Object-Z is an extension of the formal specification language Z, augmenting the class concept as a structuring facility. The paper introduces and discusses a structural mapping system from Object-Z to the programming language C++, and reports on its implementation on Unix. The structural mapping translates an Object-Z specification consisting of classes into class interfaces of C++ such as data members and prototypes of member functions. Thus it is not intended as a code generation system, but rather as a tool for analyzing specification (including syntax and type checking) and for aiding a software developer in obtaining code. Through the implementation of the mapping system several language features of Object-Z and C++ concerning object-orientation are clarified.<<ETX>></ETX>",,,object-z based,
A. Griffiths,An extended semantic foundation for Object-Z,"The paper argues that a strict notion of modularity is essential if the reuse of formally verified software components is to be achieved. Motivated by this idea, the author outlines a formal semantic domain for a sub-language of Object-Z. The semantics is based on the ""object map model""; a model which accommodates the notion of object identity, structure, and behaviour. The semantics gives a meaning to classes which is strictly modular. It also defines a composition function which takes the modular meaning of classes and returns a system meaning. A characteristic feature of the semantics is the reliance upon the notion that OO operations consist of two parts: an internal state transition and an external interaction.",,,object-z based,
Padovani L,A type checking algorithm for concurrent object protocols,Concurrent objects can be accessed and possibly modified concurrently by several running processes. It is notoriously difficult to make sure that such objects are consistent with – and are used according to – their intended protocol. In this paper we detail a type checking algorithm for concurrent objects protocols that provides automated support for this verification task. We model concurrent objects in the Objective Join Calculus and specify protocols using terms of a Commutative Kleene Algebra. The presented results are an essential first step towards the application of this static analysis technique to real-world programs.,"Objective Join Calculus, Concurrent objects, Object protocols, Behavioral type checking, Type inference, Commutative Kleene Algebra","Objective Join Protocol,
Commutative Kleee Algebra",Objective Join Calculus,
K. Chang; D. Kung; P. Hsia,OBL: a formal deduction method for object-oriented systems,"Object Behavior Logic (OBL) is proposed in order to specify object oriented system behavior. An inference engine is introduced for verifying the consistency of the systems based on the specification in OBL. OBL uses the paradigms of state machine to catch the dynamic aspect of object oriented systems in formal specification, plus the features of object oriented concepts such as inheritance, instantiation, and so forth, which separate the unique object oriented techniques from the function oriented techniques.",,OBL,OBL Model,
"Palsberg J,Zhao T",Type inference for record concatenation and subtyping,"Record concatenation, multiple inheritance, and multiple-object cloning are closely related and part of various language designs. For example, in Cardelli’s untyped Obliq language, a new object can be constructed from several existing objects by cloning followed by concatenation; an error is given in case of field name conflicts. Type systems for record concatenation have been studied by Wand, Harper and Pierce, Remy, and others; and type inference for the combination of record concatenation and subtyping has been studied by Sulzmann and by Pottier. In this paper we present a type inference algorithm for record concatenation, subtyping, and recursive types. Our example language is the Abadi–Cardelli object calculus extended with a concatenation operator. Our algorithm enables type checking of Obliq programs without changing the programs at all. We prove that the type inference problem is NP-complete.","Types, Objects, Complexity",,"Obliq based
Abadi/Cardelli based",
J. Palsberg; Tian Zhao,Efficient type inference for record concatenation and subtyping,"Record concatenation, multiple inheritance, and multiple-object cloning are closely related and part of various language designs. For example, in Cardelli's untyped Obliq language, a new object can be constructed from several existing objects by cloning followed by concatenation; an error is given in case of field name conflicts. Type systems for record concatenation have been studied by M. Wand (1991), R. Harper and B. Pierce (1991), D. Remy (1992), and others; and type inference for the combination of record concatenation and subtyping has been studied by M. Sulzmann (1997) and by F. Pottier (2000). In this paper we present the first polynomial-time type inference algorithm for record concatenation, subtyping, and recursive types. Our example language is the Abadi-Cardelli object calculus extended with a concatenation operator The type inference algorithm runs in O(n/sup 5/) time where n is the size of the program. Our algorithm enables efficient type checking of Obliq programs without changing the programs at all.",,,"Obliq based
Abadi/Cardelli based",
Ferrara P,A generic framework for heap and value analyses of object-oriented programming languages,"Abstract interpretation has been widely applied to approximate data structures and (usually numerical) value information, but their combination is needed to effectively apply static analysis to real software. In this context, we introduce a generic framework that, given a heap and a value analysis, combines them, proving formally its soundness. We plug inside this framework a standard allocation site-based pointer analysis, a TVLA-based shape analysis, and standard existing numerical domains. As far as we know, this is the first sound generic automatic framework for statically typed object-oriented programming languages combining heap and value analyses that allows to summarize and materialize heap identifiers.","Static analysis, Abstract interpretation, Generic analyzers",,OCL,
T. Ali; M. Nauman; M. Alam,An Accessible Formal Specification of the UML and OCL Meta-Model in Isabelle/HOL,"UML is the de-facto standard for system modeling. Due to its visual syntax and expressiveness, it is widely accepted and used in the industry. However, it is a semi-formal means of system specification and thus prone to inconsistencies. We believe that UML models need to be thoroughly verified because verification of UML models helps to find errors in the early system design. Object constraint language (OCL) somewhat alleviates this problem but is not always enough. Past attempts at formally specifying UML for verification include those based on simplistic Z specifications and the much more complex ones based on shallow embedding of UML and OCL in Higher Order Logic (HOL). All these approaches are either too simplistic or too complex for the software industry's purposes. In this paper, we formalize UML's class diagram and OCL constraints in the highly successful automated/interactive theorem prover Isabelle using one of its built-in logics, HOL. The aim is to create a formalization, which is accessible to the average software engineer while still being powerful enough to be able to prove consistency and other useful properties. The formalization - based on UML2.0 and OCL2.0, addresses all concepts related to class diagrams such as type definitions, attributes, operations, aggregation and association along with the syntax and semantics of OCL expressions in the context of UML class diagrams.",Algorithms;Tools & Applications;Formal Methods;System Design;Automated Theorem Prover,,OCL,
Boronat A,Structural Model Subtyping with OCL Constraints,"In model-driven engineering (MDE), models abstract the relevant features of software artefacts and model management operations, including model transformations, act on them automating large tasks of the development process. Flexible reuse of such operations is an important factor to improve productivity when developing and maintaining MDE solutions. In this work, we revisit the traditional notion of object subtyping based on subsumption, discarded by other approaches to model subtyping. We refine a type system for object-oriented programming, with multiple inheritance, to support model types in order to analyse its advantages and limitations with respect to reuse in MDE. Specifically, we extend type expressions with referential constraints and with OCL constraints. Our approach has been validated with a tool that extracts model types from (EMF) metamodels, paired with their OCL constraints, automatically and that exploits the extended subtyping relation to reuse model management operations. We show that structural model subtyping is expressive enough to support variants of model subtyping, including multiple, partial and dynamic model subtyping. The tool has received the ACM badge \Artifacts Evaluated - Functional\"".""","EMF, type theory, Model subtyping, OCL",,OCL based,
"Zibin Y,Potanin A,Li P,Ali M,Ernst MD",Ownership and Immutability in Generic Java,"The Java language lacks the important notions of ownership (an object owns its representation to prevent unwanted aliasing) and immutability (the division into mutable, immutable, and readonly data and references). Programmers are prone to design errors, such as representation exposure or violation of immutability contracts. This paper presents Ownership Immutability Generic Java (OIGJ), a backward-compatible purely-static language extension supporting ownership and immutability. We formally defined a core calculus for OIGJ, based on Featherweight Java, and proved it sound. We also implemented OIGJ and performed case studies on 33,000 lines of code.Creation of immutable cyclic structures requires a \cooking phase\"" in which the structure is mutated but the outside world cannot observe this mutation. OIGJ uses ownership information to facilitate creation of immutable cyclic structures",by safely prolonging the cooking phase even after the constructor finishes.OIGJ is easy for a programmer to use,ownership information,"OIGJ
Featherweight based",
Becker; Beiler; Hevner,Object-oriented box structures for developing complex systems,"The combination of object-oriented concepts and formal system development methods provides a powerful means for the analysis and design of complex systems. As demonstrated by (A. Hevner and H. Mills, 1993), box structures are a mathematical representation of system views that support object-oriented system development. The authors extend the box description language (BDL) in order for it to support a full description of object-oriented features such as object classes, encapsulation and inheritance. The extended language, object-oriented box description language (OOBDL), provides a semantic and syntactic means of describing objects, classes of objects, and their ability to interact with one another by message passing.<<ETX>></ETX>",,OOBDL,"OOBDL Model
description language",
"Castegren E,Wrigstad T",OOlong: An Extensible Concurrent Object Calculus,"We present OOlong, an object calculus with interface inheritance, structured concurrency and locks. The goal of the calculus is extensibility and reuse. The semantics are therefore available in a version for LATEX typesetting (written in Ott), and a mechanised version for doing rigorous proofs in Coq.","concurrency, semantics, mechanisation, object calculi",,OOlong calculus,
"Castegren E,Wrigstad T",OOlong: A Concurrent Object Calculus for Extensibility and Reuse,"We present OOlong, an object calculus with interface inheritance, structured concurrency and locks. The goal of the calculus is extensibility and reuse. The semantics are therefore available in a version for LATEX typesetting (written in Ott), a mechanised version for doing rigorous proofs in Coq, and a prototype interpreter (written in OCaml) for typechecking an running OOlong programs.","concurrency, semantics, mechanisation, object calculi",,OOlong calculus,concurrent
R. F. Paige,Integrating a Program Design Calculus and a Subset of UML,The predicative programming design calculus is integrated with an object-oriented method that uses a subset of the Unified Modelling Language. The integration is carried out so as to make the calculus and refinement techniques more applicable to the development of large-scale object-oriented software. The two methods are integrated using a meta-method for formal method integration based on heterogeneous notations. We demonstrate how the methods being integrated complement each other and outline the use of the integrated method in a case study.,,"predicate calculus,
uml formalism","Paige's method
UML based",
Newman RM,The ClassiC programming language and design of synchronous concurrent object oriented languages,"Many real-time systems make use of concurrent programming systems and are often designed using object oriented design methods. Concurrent Object Oriented Languages (COOLS) are a class of programming language that integrates the facilities of concurrent and object oriented programming in an integrated rather than orthogonal manner. With the increasing interest in the use of object oriented languages such as C++ for the programming of embedded and real-time systems COOLs seem to be a natural candidate for such tasks. Several COOLs have been described in the literature which address the requirements of concurrent programming, inter-process communication (IPC) and synchronisation in various different ways. This paper discusses one such language, ClassiC, and examines the approach to this problem taken in its design. In particular, it is shown that the features of ClassiC allow derivation of active classes from other active classes. It is shown how this property can be used to overcome some of the problems associated with synchronous IPC schemes while maintaining the advantages of them and how the use of the asynchronous IPC model allows verification of synchronisation and deadlock properties based on the use of CSP methods.","Concurrency, Object-orientation, Formal methods, Programming, Real-time systems",,petri nets,
"Cardelli L,Martini S,Mitchell JC,Scedrov A",An Extension of System F with Subtyping,"System F is a well-known typed λ-calculus with polymorphic types, which provides a basis for polymorphic programming languages. We study an extension of F, called F<: (pronounced ef-sub), that combines parametric polymorphism with subtyping. The main focus of the paper is the equational theory of F<:, which is related to PER models and the notion of parametricity. We study some categorical properties of the theory when restricted to closed terms, including interesting categorical isomorphisms. We also investigate proof-theoretical properties, such as the conservativity of typing judgments with respect to F. We demonstrate by a set of examples how a range of constructs may be encoded in F<:. These include record operations and subtyping hierarchies that are related to features of object-oriented languages.",,,petri nets,
"Nestmann U,Hüttel H,Kleist J,Merro M",Aliasing Models for Mobile Objects,"In Obliq, a lexically scoped, distributed, object-oriented programming language, object migration was suggested as the creation of a copy of the state of an object at the target site, followed by turning the object itself into an alias, also called surrogate, for the remote copy. We consider the creation of object surrogates as an abstraction of the above-mentioned style of migration. We introduce Øjeblik, a typed distribution-free subset of Obliq, and provide four different configuration-style semantics, which only differ in the respective aliasing model. We show that two of the semantics, one of which matches Obliq's implementation, render migration unsafe, while our new proposal allows for safe migration at least for a large class of program contexts. In addition, we propose a type system that allows a programmer to statically guarantee that programs belong to that class. Our work suggests a straightforward repair of Obliq's aliasing model.",,,petri nets,
B. Bauskar; B. Mikolajczak,Modeling inheritance anomaly in concurrent systems using colored Petri nets,"Object oriented design supports encapsulation, inheritance, and polymorphism. Formal specification of concurrency is possible in the object oriented design. Concurrency with inheritance raises inheritance anomaly, where, synchronization constraints and source code of inherited methods shows disagreement in their behavior. Due to the hierarchical structure of colored Petri nets model and direct inclusion of concurrency, colored Petri nets can be used to solve inheritance anomaly. In this paper, we propose that colored Petri nets, the formal mathematical modeling tool of concurrent systems, can be used to model concurrent object oriented design. The graphical and executable nature of colored Petri net models helps in simulation, verification, and validation of the designed system",,,petri nets,
M. Ceska; V. Janousek; T. Vojnar,"Object-oriented Petri nets, their simulation, and analysis","The article presents the so-called object-oriented Petri nets (OOPNs) combining advantages of Petri nets and object-orientation. OOPNs are described mostly informally, but the key concepts of their formal definition are also included. Furthermore, the computer-aided tool called PNtalk which supports editing and simulating OOPNs is briefly mentioned, too. Finally, problems accompanying formal analysis of OOPNs, stemming from the high dynamism of models based on them, are discussed.",,,petri nets based,
G. Bastidas; E. Villani; F. Junqueira; P. E. Miyagi,Open distributed supervisory system design using Petri nets,"The design of supervisory system for automated environments can be seen as a task involving techniques and methods of two main areas: software and control engineering. In this context, the purpose of this work is to introduce a new approach for open distributed supervisory system design based on the merging of traditional techniques of software engineering (such as object-oriented concepts) with formal models of discrete events dynamic systems- (such as Petri nets). In this first level of abstraction, the reference model of open distributed processing (RM-ODP) is used as a standard architectural framework for the construction of open distributed system. Based on the RM-ODP, the unified modeling language (UML) diagrams are built as a second level of abstraction. Finally, the Petri nets (the third level of abstraction) are used throughout the process in order to guarantee the coherence among the UML models from requirement analysis to implementation, and to provide formal models of the system.",,,petri nets based,
"Allende E,Callaú O,Fabry J,Tanter É,Denker M",Gradual typing for Smalltalk,"Being able to combine static and dynamic typing within the same language has clear benefits in order to support the evolution of prototypes or scripts into mature robust programs. While being an emblematic dynamic object-oriented language, Smalltalk is lagging behind in this regard. We report on the design, implementation and application of Gradualtalk, a gradually-typed Smalltalk meant to enable incremental typing of existing programs. The main design goal of the type system is to support the features of the Smalltalk language, like metaclasses and blocks, live programming, and to accommodate the programming idioms used in practice. We studied a number of existing projects in order to determine the features to include in the type system. As a result, Gradualtalk is a practical approach to gradual types in Smalltalk, with a novel blend of type system features that accommodate most programming idioms.","Type systems, Gradual typing, Smalltalk",,"petri nets,
UML",
"van Bakel S,Rowe RN",Semantic Predicate Types and Approximation for Class-Based Object Oriented Programming,"We apply the principles of the intersection type discipline to the study of class-based object oriented programs and; our work follows from a similar approach (in the context of Abadi and Cardelli's ς-object calculus) taken by van Bakel and de'Liguoro. We define an extension of Featherweight Java, pFJ, and present a predicate system which we show to be sound and expressive. We also show that our system provides a semantic underpinning for the object oriented paradigm by generalising the concept of approximant from the Lambda Calculus and demonstrating an approximation result: all expressions to which we can assign a predicate have an approximant that satisfies the same predicate. Crucial to this result is the notion of predicate language, which associates a family of predicates with a class.",,,"pFJ
Featherweight based",
M. Barrio; P. de la Fuente,A formal model of concurrency for distributed object-oriented systems,"It is widely accepted that object-oriented constructions can be used as a pertinent basis for the support of distributed systems consisting of concurrently executing objects that communicate and interoperate among them. In this context, distributed object systems are represented from a process-oriented perspective which uses the process as the basic modelling structure. This point of view allows us to model concurrent objects as a collection of interacting processes, each of them describing a pattern of behaviour. We aim to provide a formal foundation for object-oriented constructions. To do so, we present a formal model of concurrent objects based on a well-defined process theory, the /spl pi/-calculus, which offers a very effective mechanism of specification and verification. The election of the /spl pi/-calculus is justified by some of its features, e.g., mobility and higher-order constructions, for they will be essential to the description of some object behaviour and constructions.",,,pi calculus,
"Philippou A,Walker D",On transformations of concurrent-object programs,Transformation rules which increase the scope for concurrent activity within systems prescribed by programs of concurrent-object languages are given. Their correctness is proved on the basis of a semantic definition by translation to an extension of the π-calculus. The main theoretical development concerns the notions of confluence and partial confluence of processes.,,,pi-calculus,
"Naden K,Bocchino R,Aldrich J,Bierhoff K",A Type System for Borrowing Permissions,"In object-oriented programming, unique permissions to object references are useful for checking correctness properties such as consistency of typestate and noninterference of concurrency. To be usable, unique permissions must be borrowed --- for example, one must be able to read a unique reference out of a field, use it for something, and put it back. While one can null out the field and later reassign it, this paradigm is ungainly and requires unnecessary writes, potentially hurting cache performance. Therefore, in practice borrowing must occur in the type system, without requiring memory updates. Previous systems support borrowing with external alias analysis and/or explicit programmer management of fractional permissions. While these approaches are powerful, they are also awkward and difficult for programmers to understand. We present an integrated language and type system with unique, immutable, and shared permissions, together with new local permissions that say that a reference may not be stored to the heap. Our system also includes change permissions such as unique>>unique and unique>>none that describe how permissions flow in and out of method formal parameters. Together, these features support common patterns of borrowing, including borrowing multiple local permissions from a unique reference and recovering the unique reference when the local permissions go out of scope, without any explicit management of fractions in the source language. All accounting of fractional permissions is done by the type system \under the hood.\"" We present the syntax and static and dynamic semantics of a formal core language and state soundness results. We also illustrate the utility and practicality of our design by using it to express several realistic examples.""","immutability, types, uniqueness, borrowing, permissions",,Plaid based,
"Garcia R,Cimini M",Principal Type Schemes for Gradual Programs,"Gradual typing is a discipline for integrating dynamic checking into a static type system. Since its introduction in functional languages, it has been adapted to a variety of type systems, including object-oriented, security, and substructural. This work studies its application to implicitly typed languages based on type inference. Siek and Vachharajani designed a gradual type inference system and algorithm that infers gradual types but still rejects ill-typed static programs. However, the type system requires local reasoning about type substitutions, an imperative inference algorithm, and a subtle correctness statement.This paper introduces a new approach to gradual type inference, driven by the principle that gradual inference should only produce static types. We present a static implicitly typed language, its gradual counterpart, and a type inference procedure. The gradual system types the same programs as Siek and Vachharajani, but has a modular structure amenable to extension. The language admits let-polymorphism, and its dynamics are defined by translation to the Polymorphic Blame Calculus.The principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing. To expose this difference, we distinguish static type parameters from gradual type parameters and reinterpret gradual type consistency accordingly. The resulting extension enables programs to be interpreted using either the polymorphic or monomorphic Blame Calculi.","gradual typing, type inference",,"Polymorphic Blame Calculus based
system F based",
"France R,Evans A,Lano K,Rumpe B",The UML as a formal modeling notation,"The Unified Modeling Language (UML) is an Object Management Group (OMG) object-oriented (OO) modeling notation standard. It consists of a set of notations for modeling systems from a variety of views and at varying levels of abstraction. While the UML reflects some of the best OO modeling experiences available, it suffers from a lack of precise semantics that is necessary if one is to use the notations to precisely model systems and to rigorously reason about the models. In this paper we discuss some of the problems with the current UML semantic document and present the approach that the precise UML group (pUML) group is using to develop a precise semantics for the UML. The approach utilizes mathematical techniques to explore and gain insights into appropriate semantics for UML modeling concepts. The insights and formal expressions will then be used to develop a UML semantics document written in natural language that defines the semantics in a precise, consistent, and understandable manner.","UML, Formal methods, Graphical notations",pUML,"pUML
UML based",
Hutchins DS,Pure Subtype Systems,"This paper introduces a new approach to type theory called pure subtype systems . Pure subtype systems differ from traditional approaches to type theory (such as pure type systems) because the theory is based on subtyping, rather than typing. Proper types and typing are completely absent from the theory; the subtype relation is defined directly over objects. The traditional typing relation is shown to be a special case of subtyping, so the loss of types comes without any loss of generality.Pure subtype systems provide a uniform framework which seamlessly integrates subtyping with dependent and singleton types. The framework was designed as a theoretical foundation for several problems of practical interest, including mixin modules, virtual classes, and feature-oriented programming.The cost of using pure subtype systems is the complexity of the meta-theory. We formulate the subtype relation as an abstract reduction system, and show that the theory is sound if the underlying reductions commute. We are able to show that the reductions commute locally, but have thus far been unable to show that they commute globally. Although the proof is incomplete, it is ``close enough'' to rule out obvious counter-examples. We present it as an open problem in type theory.","subtyping, transitivity elimination, abstract reduction systems, dependent types, singleton types",,"Pure subtype system
System F based",
"Ramananandro T,Dos Reis G,Leroy X","A Mechanized Semantics for C++ Object Construction and Destruction, with Applications to Resource Management","We present a formal operational semantics and its Coq mechanization for the C++ object model, featuring object construction and destruction, shared and repeated multiple inheritance, and virtual function call dispatch. These are key C++ language features for high-level system programming, in particular for predictable and reliable resource management. This paper is the first to present a formal mechanized account of the metatheory of construction and destruction in C++, and applications to popular programming techniques such as \resource acquisition is initialization\"". We also report on irregularities and apparent contradictions in the ISO C++03 and C++11 standards.""","Coq, classes, constructors, destructors, mechanized semantics, objects, C++",,Ramananandro/Dos Reis/Leroy model,
Z. Wang; X. Yu; G. Pu; L. Feng; H. Zhu; J. He,Execution Semantics for rCOS,"rCOS, the abbreviation of Refinement Calculus for Object Systems, is designed to present mathematical characterization of essential object-oriented concepts for an object-based language with a rich variety of features including subtypes, inheritance, type casting, dynamic binding and polymorphism. This paper represents an operational semantics for the rCOS language based on labeled transition systems. The result semantics shows the process of how the effects of an rCOS program are produced. It can be a secure guide for the implementation of the rCOS language, which is being carried out by our group. For the purpose of extending verifiability and functionality, a set of auxiliary language features is introduced to the rCOS language. Concurrent execution structure is designed to specify multi-threaded programs. Also the simulation is introduced to specify the observable behaviors of objects, and it can be regarded as the refinement relation defined in denotational domain to some extent.",,rCos,"rCos Model
algebraic language",
"Jifeng H,Li X,Liu Z",rCOS: A refinement calculus of object systems,"This article presents a mathematical characterization of object-oriented concepts by defining an observation-oriented semantics for a relational object-based language with a rich variety of features including subtypes, visibility, inheritance, type casting, dynamic binding and polymorphism. The language can be used to specify object-oriented designs as well as programs. We present a calculus that supports both structural and behavioural refinement of object-oriented designs. The design calculus is based on the predicate logic in Hoare and He's Unifying Theories of Programming (UTP).","Object orientation, Refinement, Semantics, UTP",,"rCos Model
algebraic language",
"Huang W,Milanova A,Dietl W,Ernst MD",Reim & ReImInfer: Checking and Inference of Reference Immutability and Method Purity,"Reference immutability ensures that a reference is not used to modify the referenced object, and enables the safe sharing of object structures. A pure method does not cause side-effects on the objects that existed in the pre-state of the method execution. Checking and inference of reference immutability and method purity enables a variety of program analyses and optimizations. We present ReIm, a type system for reference immutability, and ReImInfer, a corresponding type inference analysis. The type system is concise and context-sensitive. The type inference analysis is precise and scalable, and requires no manual annotations. In addition, we present a novel application of the reference immutability type system: method purity inference.To support our theoretical results, we implemented the type system and the type inference analysis for Java. We include a type checker to verify the correctness of the inference result. Empirical results on Java applications and libraries of up to 348kLOC show that our approach achieves both scalability and precision.","reference immutability, method purity, type system, inference",,ReIm & ReImInfer,
A. Cavalcanti; D. A. Naumann,A weakest precondition semantics for refinement of object-oriented programs,"We define a predicate-transformer semantics for an object oriented language that includes specification constructs from refinement calculi. The language includes recursive classes, visibility control, dynamic binding, and recursive methods. Using the semantics, we formulate notions of refinement. Such results are a first step toward a refinement calculus.",,ROOL,ROOL PL,
"Vekris P,Cosman B,Jhala R",Refinement Types for TypeScript,"We present Refined TypeScript (RSC), a lightweight refinement type system for TypeScript, that enables static verification of higher-order, imperative programs. We develop a formal system for RSC that delineates the interaction between refinement types and mutability, and enables flow-sensitive reasoning by translating input programs to an equivalent intermediate SSA form. By establishing type safety for the intermediate form, we prove safety for the input programs. Next, we extend the core to account for imperative and dynamic features of TypeScript, including overloading, type reflection, ad hoc type hierarchies and object initialization. Finally, we evaluate RSC on a set of real-world benchmarks, including parts of the Octane benchmarks, D3, Transducers, and the TypeScript compiler. We show how RSC successfully establishes a number of value dependent properties, such as the safety of array accesses and downcasts, while incurring a modest overhead in type annotations and code restructuring.","Immutability, Type Systems, TypeScript, Refinement Types",,"RSC
Refinemet TypeScript",
"Rastogi A,Swamy N,Fournet C,Bierman G,Vekris P",Safe & Efficient Gradual Typing for TypeScript,"Current proposals for adding gradual typing to JavaScript, such as Closure, TypeScript and Dart, forgo soundness to deal with issues of scale, code reuse, and popular programming patterns. We show how to address these issues in practice while retaining soundness. We design and implement a new gradual type system, prototyped for expediency as a 'Safe' compilation mode for TypeScript. Our compiler achieves soundness by enforcing stricter static checks and embedding residual runtime checks in compiled code. It emits plain JavaScript that runs on stock virtual machines. Our main theorem is a simulation that ensures that the checks introduced by Safe TypeScript (1) catch any dynamic type error, and (2) do not alter the semantics of type-safe TypeScript code.Safe TypeScript is carefully designed to minimize the performance overhead of runtime checks. At its core, we rely on two new ideas: differential subtyping, a new form of coercive subtyping that computes the minimum amount of runtime type information that must be added to each object; and an erasure modality, which we use to safely and selectively erase type information. This allows us to scale our design to full-fledged TypeScript, including arrays, maps, classes, inheritance, overloading, and generic types.We validate the usability and performance of Safe TypeScript empirically by type-checking and compiling around 120,000 lines of existing TypeScript source code. Although runtime checks can be expensive, the end-to-end overhead is small for code bases that already have type annotations. For instance, we bootstrap the Safe TypeScript compiler (90,000 lines including the base TypeScript compiler): we measure a 15% runtime overhead for type safety, and also uncover programming errors as type safety violations. We conclude that, at least during development and testing, subjecting JavaScript/TypeScript programs to safe gradual typing adds significant value to source type annotations at a modest cost.","javascript, gradual typing, typescript, type safety",,SafeTS,
"Capecchi S,Coppo M,Dezani-Ciancaglini M,Drossopoulou S,Giachino E",Amalgamating sessions and methods in object-oriented languages with generics,"We suggest an amalgamation of communication-based programming (centered on sessions) and object-oriented programming, whereby sessions between concurrent threads are amalgamated with methods. In our proposal, threads consist of the execution of session bodies on objects and communicate with each other by asynchronously sending/receiving objects on channels. The response to a session request is based on the name of the request and the class of the object receiving the request. The decision of how to continue a session is based on the class of the object sent/received. Sessions can be delegated to other sessions, although sessions themselves are not first class objects. We demonstrate our ideas through a core language with generic types, SAMg, and an example. We then formalize a small calculus, FSAMg, and prove subject reduction and progress. The latter property is notoriously difficult to achieve in concurrent calculi.","Session types, Foundations of object-oriented programming, Subject reduction, Progress",,"SAM PL
Featherweight based",
H. W. Schmidt; J. Chen,Reasoning about concurrent objects,"Embedded specifications in object-oriented (OO) languages such as Eiffel and Sather are based on a rigorous approach towards validation, compatibility and reusability of sequential programs. The underlying method of ""design-by-contract"" is based on Hoare logic for which concurrency extensions exist. However concurrent OO languages are still in their infancy. They have inherently imperative facets, such as object identity, sharing, and synchronisation, which cannot be ignored in the semantics. Any marriage of objects and concurrency requires a trade-off in a space of intertwined qualities. The paper summarises our work on a type system, calculus and an operational model for concurrent objects in a minimal extension of the Eiffel and Sather languages (cSather). We omit concurrency control constructs and instead use assertions as synchronisation constraints for asynchronous functions. We show that this provides a framework in which subtyping and concurrency can coexist.",,Sather,Sather Model,
Ierusalimschy R,A denotational approach for type-checking in object-oriented programming languages,"Starting with a pragmatical (but formal) definition of type in object-oriented languages, this paper proposes a method to test type safety in this kind of language. We say that a language is (type) safe if it ensures that, during the execution of a correct program, every message sent to an object is matched by an appropriate method. We define a “typical” object oriented programming language, featuring multiple inheritance, recursive types, and separation between specifications and implementations. Then, we give a formal definition for its type system, and a denotational semantics for the execution of the language, based on message passing. Finally, we formally prove that our language is type safe. Along the progress of the work, better understanding is gained about many problems related with type systems in object-oriented languages.","semantics of programming languages, type systems, object oriented programming",,"School PL
VDM based",
C. Secchi; M. Bonfe; C. Fantuzzi,Design by Extension and Inheritance of Behavior in Dynamical Systems,"The paper introduces a formal definition of inheritance, which is a cardinal concept in object-oriented software, for dynamical systems. The proposed definition exploits the coalgebraic description of software artifacts to provide a connection between the behavioral approach for modeling dynamical systems and the object-oriented approach for software modeling and design. This definition allows to apply the design by extension methodology, widely used in software engineering, to the design of components of manufacturing systems",,"inheritance
categorical","Secchi/Bonfe/Fantuzzi model
design by extesion",
"Lievens D,Harrison W",Abstraction over implementation structure with symmetrically encapsulated multimethods,"In object-oriented languages, methods are encapsulated, hence module interfaces are made up of sets of methods partitioned along the objects or classes that make up the module. This prevents abstraction over the implementation structure of applications. Any change in method placement may cause a global effect that ripples through all clients depending on that method. Sometimes this unduly restricts the scope of software evolution, particularly for methods with multiple parameters where there is no clear owner. We investigate a simple scheme where methods may be defined in the classes of any of their parameters. This allows client code to be oblivious to choice of method placement, and therefore immune against it changing. When combined with multiple dispatch, this scheme allows for modular extensibility, where methods defined in one class may be overloaded by methods defined in classes that are not its subclasses. We detail our proposal by extending a core calculus of class-based object-oriented languages with these symmetrically encapsulated multimethods, and prove the result sound. It is well-known that multiple dispatch is at odds with modular type-checking. We also discuss different strategies that can be followed to mitigate the type-checking problem and propose variants of the original calculus that are amenable to modular checking.","Object-orientation, Encapsulated multimethods, Modular type-checking",,"SFMJ
Featherweight based",
"Houari T,Jean-Claude C",An Object Language with States: SOL,"Synchronous reactive systems continually react with their environment. Based on formal hypothesis and complete semantics, this approach brings rigor and flexibility. The aim of some research is to specify a common code which can be used as an intermediate code or gateway for the present synchronous languages, this paper is consistent with this spirit. SOL (State Object Language) is proposed and its concepts are presented. From an object code of synchronous language, the equivalent SOL program is generated. The result is a clean program with a high abstraction level, this allows the application evolution and maintenance in an incremental way.","object-oriented programming, synchronous theory, finite automata, states, statecharts",,SOFL,
Tsuiki H,A domain-theoretic semantics of lax generic functions,"The semantic structure of a polymorphic calculus λm is studied. λm is defined over a hierarchical type structure, and a function in this calculus, called a generic function, can be composed from more than one lambda expression and the ways it behaves on each type are weakly related in that it lax commutes with the coercion functions defined from the subtypes to the supertypes. Since laxness is intermediate between ad hocness (behaviors on each type are not related) and coherency (commuting with the coercion functions), λm has syntactic properties lying between those of calculi with ad hoc generic functions and coherent generic functions studied in Tsuiki (Math. Struct. Comput. Sci. 8 (1998) 321). That is, although λm allows self application and thus is not normalizing, it does not have any unsolvable terms. For this reason, all the semantic domains are connected by mutually recursive equations and, at the same time, they do not have the least elements.We solve them by considering fibrations and expressing the equations as a recursive equation about fibrations. We also show the adequacy theorem for λm following the construction of Pitts and use it to derive some syntactic properties.","Overriding, Lax transformation, Fibration, Domain theory, Object oriented",,SOFL,
"Caltais G,Meyer B",On the verification of SCOOP programs,"In this paper we focus on the development of a unifying framework for the formal modeling of an object oriented-programming language, its underlying concurrency model and their associated analysis tools. More precisely, we target SCOOP – an elegant concurrency model, recently formalized based on Rewriting Logic (RL) and Maude. SCOOP is implemented in Eiffel and its applicability is demonstrated also from a practical perspective, in the area of robotics programming. Our contribution consists of devising and integrating an alias analyzer and a Coffman deadlock detector under the roof of the same RL-based semantic framework of SCOOP. This enables using the Maude rewriting engine and its LTL model-checker “for free,” in order to perform the analyses of interest. We discuss the limitations of our approach for model-checking deadlocks and provide possible workarounds for the state space explosion problem. On the aliasing side, we propose an extension of a previously introduced alias calculus based on program expressions, to the setting of unbounded program executions. Moreover, we devise a corresponding executable specification easily implementable on top of the SCOOP formalization. An important property of our extension is that, in non-concurrent settings, the corresponding alias expressions can be over-approximated in terms of a notion of regular expressions. This further enables us to derive an algorithm for computing a sound over-approximation of the “may aliasing” information, where soundness stands for the lack of false negatives.","SCOOP, Operational semantics, Alias analysis, Deadlock detection, Rewriting logic",,SOFL,
Oliver Stehr M,CINNI - A Generic Calculus of Explicit Substitutions and its Application to λ- ς- and π-Calculi,"We approach the general problem of representing higher-order languages, that are usually equipped with special variable binding constructs, in a less specialized first-order framework such as membership equational logic and the corresponding version of rewriting logic. The solution we propose is based on CINNI, a new calculus of explicit substitutions that makes use of a term representation that contains both the standard named notation and de Bruijn's indexed notation as special subcases. The calculus is parametric in the syntax of the object language, which allows us to apply it to different object languages such as λ-calculus, Abadi and Cardelli's object calculus (ς-calculus) and Milner's calculus of communicating mobile processes (π-calculus). As a practical result we obtain executable formal representations of these object languages in Maude with a representational distance close to zero.","Higher-Order Languages, Explicit Substitutions, Logical Frameworks, Rewriting Logic, Maude, Lambda-Calculus, Sigma-Calculus, Pi-Calculus",,SOFL,
Shaoying Liu,SOFL: a formal engineering methodology for industrial applications,"Summary form only given, as follows. A major challenge for formal methods is to effectively address the needs of industry and achieve wide acceptance. This challenge remains unmet, as formal methods are difficult to use and their application consumes prohibitive amounts of resource. Much research on the integration of available formal methods (e.g. Z, VDM, B-method) and either structured methodology or object-oriented methodology has been conducted to make formal methods more practical, but with limited success. No attempt has yet been made to integrate the three approaches of formal methods, structured methodology and object-oriented methodology to take advantage of the desirable features of the three approaches. As one approach to the solution of these problems, we propose a language called SOFL (Structured Object-oriented Formal Language) for system development. It supports the concept that a system can be constructed using the structured methodology in the early stages of its development, and by using object-oriented methodology at later, more detailed levels. During the complete system development process, formal methods are applied in a manner that best uses their capabilities.",,,SOFL,
S. Liu; Jin Song Dong,Class and module in SOFL,"SOFL is a formal language and method for system specification and design. It was developed by integrating Petri Nets, Data Flow Diagrams, and VDM-SL. As the major feature of the original SOFL method is to use structured techniques for analysis and specification, and object-oriented techniques for design and implementation, SOFL has its own implementation language that is similar to C++. However during our recent work of applying SOFL to software systems, the transformation of structured specifications to object-oriented implementations creates some difficulties, simply because of paradigms mismatch. In this paper we extend SOFL to a formal object-oriented language and method while keeping its structured features. This will allow powerful object-oriented reuse mechanisms, such as class inheritance and object composition, to be utilized in the early phases, and transformation from SOFL specifications to commercial object-oriented programming languages to be readily achieved.",,,SOFL,
Jin Song Dong; Shaoying Liu,The semantics of extended SOFL,"SOFL (structured-object-based-formal language) has been extended to a formal object-oriented language and method while keeping its structured features. This extension allows powerful object-oriented reuse mechanisms, such as class inheritance and object composition, to be utilized in the early design phases. This paper presents the semantics for this extended SOFL, and further demonstrates the extendibility and reusability of the object-oriented semantic models of SOFL.",,,SOFL,
C. Ho-Stuart; Shaoying Liu,A formal operational semantics for SOFL,"SOFL (Structured-Object-Based-Formal Language) is a formal language and method for practical systems development. As a language, it integrates data flow diagrams, VDM-SL, and Petri nets to provide a graphical and textual formal notation for specification construction. Previous publications introducing SOFL are based on its informal semantics. We provide a formal operational semantics which gives a firm foundation for consistent understanding and application of SOFL in practical systems development. Development of the semantics, and application of SOFL to practical systems, have led to some changes in the original definitions. This formal semantics will serve as a firm foundation for building an effective support environment for SOFL.",,,SOFL,
N. Soundarajan; S. Fridella,Behavioral subtyping and behavioral enrichment of multimethods,"Multimethods can provide considerable flexibility to the OO (object oriented) designer. The authors' goal is to address issues related to reasoning about the behavior of multimethods. Specifically they show that the important notion of behavioral subtyping can be naturally extended to multimethods. The authors also investigate how, when reasoning about code that invokes multimethods, one can appeal to the enriched behavior provided by the specialized methods.",,,Soundarajan/Fridella model,
N. Soundarajan; S. Fridella,Inheriting and modifying behavior,"In languages such as C++, the mechanism of protected members is critical to making inheritance work. It allows access to some of the intervals of a base class B to the designer of a derived class D, while denying it to clients of B. The authors develop a formal approach in which class behavior is precisely specified in terms of an abstract specification and a concrete specification, the former for use by a client, the latter containing information about how the protected members change, for use by a derived class designer. They present rules that allow one to establish that a class meets both specifications.",,,Soundarajan/Fridella model,
J. M. Smith; D. Stotts,SPQR: flexible automated design pattern extraction from source code,"Previous automated approaches to discovering design patterns in source code have suffered from a need to enumerate static descriptions of structural and behavioral relationships, resulting in a finite library of variations on pattern implementation. Our approach, system for pattern query and recognition, or SPQR, differs in that we do not seek statically to encode each variant of the patterns that we wish to find. Our system finds pattern variants that were not explicitly defined, but instead are inferred dynamically during code analysis by a theorem prover, providing practical tool support for software construction, comprehension, maintenance, and refactoring. We use a logical inference system to reveal large numbers of patterns and their variations from a small number of definitions by encoding in a formal denotational semantics a small number of fundamental OO concepts (elemental design patterns), encode the rules by which these concepts are combined to form patterns (reliance operators), and encode the structural/behavioral relationships among components of objects and classes (rho-calculus). A chain of fully automated tools provides a path from source code to revealed patterns. We describe our approach in this paper with a concrete example to drive the discussion, accompanied by formal treatment of the foundational topics.",,,SPQR,
F. Arcelli; S. Masiero; C. Raibulet,Elemental Design Patterns Recognition In Java,"The decomposition of design patterns into simpler elements may reduce significantly the creation of variants in forward engineering, while it increases the possibility of identifying applied patterns in reverse engineering. Nevertheless, there are few reverse engineering tools that exploit the decomposition of patterns (i.e., FUJABA, SPQR). The SPQR approach introduces a catalog of elemental design patterns (EDP) and a rule set based on sigma-calculus through which EDPs are defined and composed into design patterns. Considering the SPQR approach particularly interesting, we propose a novel solution for defining and detecting EDPs and, further, design patterns. Our approach defines EDPs as logical functions of eight symbolic variables, each variable representing a method call (e.g., method name, method signature, method declaration, this reference, super reference) or a class property (superclass, same family, same object). An EDP detector has been developed based on this approach, representing a starting point for future developments towards design pattern recognition in the reverse engineering context",,,SPQR based,
"Summers AJ,Mueller P",Freedom before Commitment: A Lightweight Type System for Object Initialisation,"One of the main purposes of object initialisation is to establish invariants such as a field being non-null or an immutable data structure containing specific values. These invariants are then implicitly assumed by the rest of the implementation, for instance, to ensure that a field may be safely dereferenced or that immutable data may be accessed concurrently. Consequently, letting an object escape from its constructor is dangerous; the escaping object might not yet satisfy its invariants, leading to errors in code that relies on them. Nevertheless, preventing objects entirely from escaping from their constructors is too restrictive; it is often useful to call auxiliary methods on the object under initialisation or to pass it to another constructor to set up mutually-recursive structures.We present a type system that tracks which objects are fully initialised and which are still under initialisation. The system can be used to prevent objects from escaping, but also to allow safe escaping by making explicit which objects might not yet satisfy their invariants. We designed, formalised and implemented our system as an extension to a non-null type system, but it is not limited to this application. Our system is conceptually simple and requires little annotation overhead; it is sound and sufficiently expressive for many common programming idioms. Therefore, we believe it to be the first such system suitable for mainstream use.","simple, modular, sound, expressive, non-null, type-system, initialisation",,Summers/Mueller type system,
"Yang Y,Oliveira BC",Unifying Typing and Subtyping,"In recent years dependent types have become a hot topic in programming language research. A key reason why dependent types are interesting is that they allow unifying types and terms, which enables both additional expressiveness and economy of concepts. Unfortunately there has been much less work on dependently typed calculi for object-oriented programming. This is partly because it is widely acknowledged that the combination between dependent types and subtyping is particularly challenging.This paper presents λ I≤, which is a dependently typed generalization of System F≤. The resulting calculus follows the style of Pure Type Systems, and contains a single unified syntactic sort that accounts for expressions, types and kinds. To address the challenges posed by the combination of dependent types and subtyping, λ I≤ employs a novel technique that unifies typing and subtyping. In λ I≤ there is only a judgement that is akin to a typed version of subtyping. Both the typing relation, as well as type well-formedness are just special cases of the subtyping relation. The resulting calculus has a rich metatheory and enjoys of several standard and desirable properties, such as subject reduction, transitivity of subtyping, narrowing as well as standard substitution lemmas. All the metatheory of λ I≤ is mechanically proved in the Coq theorem prover. Furthermore, (and as far as we are aware) λ I≤ is the first dependently typed calculus that completely subsumes System F≤, while preserving various desirable properties.","dependent types, subtyping, object-oriented programming",,"system F based
DOT based",
"Xu H,Yu S",Type Theory and Language Constructs for Objects with States,"In current class-based Object-Oriented Programming Languages (OOPLs), object types include only static features. How to add object dynamic behaviors modeled by Harel's statecharts into object types is a challenging task. We propose adding states and state transitions, which are largely unstated in object type theory, into object type definitions and typing rules. We argue that dynamic behaviors of objects should be part of object type definitions. We propose our type theory, the τ-calculus, which refines Abadi and Cardelli's ζ-calculus, in modeling objects with their dynamic behaviors. In our proposed type theory, we also explain that a subtyping relation between object types should imply the inclusion of their dynamic behaviors. By adding states and state transitions into object types, we propose modifying programming language constructs for state tracking.","object types, object dynamic behaviors, -calculus, -calculus, programming language constructs, state tracking",,"tau calculus
Abadi/Cardelli based
",
"Takikawa A,Strickland TS,Dimoulas C,Tobin-Hochstadt S,Felleisen M",Gradual Typing for First-Class Classes,"Dynamic type-checking and object-oriented programming often go hand-in-hand; scripting languages such as Python, Ruby, and JavaScript all embrace object-oriented (OO) programming. When scripts written in such languages grow and evolve into large programs, the lack of a static type discipline reduces maintainability. A programmer may thus wish to migrate parts of such scripts to a sister language with a static type system. Unfortunately, existing type systems neither support the flexible OO composition mechanisms found in scripting languages nor accommodate sound interoperation with untyped code. In this paper, we present the design of a gradual typing system that supports sound interaction between statically- and dynamically-typed units of class-based code. The type system uses row polymorphism for classes and thus supports mixin-based OO composition. To protect migration of mixins from typed to untyped components, the system employs a novel form of contracts that partially seal classes. The design comes with a theorem that guarantees the soundness of the type system even in the presence of untyped components.","first-class classes, contracts, blame theorem (proof technique), design by contract, row polymorphism, gradual typing, sealing",,TFCC,
"Jagannathan S,Vitek J,Welc A,Hosking A",A transactional object calculus,"A transaction defines a locus of computation that satisfies important concurrency and failure properties. These so-called ACID properties provide strong serialization guarantees that allow us to reason about concurrent and distributed programs in terms of higher-level units of computation (e.g., transactions) rather than lower-level data structures (e.g., mutual-exclusion locks). This paper presents a framework for specifying the semantics of a transactional facility integrated within a host programming language. The TFJ calculus, an object calculus derived from Featherweight Java, supports nested and multi-threaded transactions. We give a semantics to TFJ that is parametrized by the definition of the transactional mechanism that permits the study of different transaction models. We give two instantiations: one that defines transactions in terms of a versioning-based optimistic concurrency model, and the other which specifies transactions in terms of a pessimistic two-phase locking protocol, and present soundness and serializability properties for our semantics.","Transactions, Threads, Object calculus, Nesting, Optimistic concurrency, Two-phase locking",,"TFJ calculus
Featherweight based",
Ryu S,ThisType for Object-Oriented Languages: From Theory to Practice,"In object-oriented programs, objects often provide methods whose parameter types or return types are the object types themselves. For example, the parameter types of binary methods are the types of their receiver objects, and the return types of some factory methods are the types of their enclosing objects. However, most object-oriented languages do not support such methods precisely because their type systems do not support explicit recursive types, which lead to a mismatch between subclassing and subtyping. This mismatch means that an expression of a subclass may not always be usable in a context where an expression of a superclass is expected, which is not intuitive in an object-oriented setting. Researchers have proposed various type-sound approaches to support methods with types of their enclosing object types denoted by some variants of ThisType, but they reject reasonable and useful methods due to unpermissive type systems or they use less precise declared inexact types rather than runtime exact types.In this article, we present a thorough approach to support methods with ThisTypes: from a new encoding of objects in a typed lambda calculus that allows subtyping by subclassing to an open-source implementation as an extension of the Java programming language. We first provide real-world examples that motivate the need for ThisTyped methods to precisely describe desired properties of programs. We define a new object encoding that enables subtyping by subclassing even in the presence of negative occurrences of type recursion variables by distinguishing object types from existential object types. Based on this object encoding, we formalize language features to support ThisTyped methods with a core calculus CoreThisJava, and prove its type soundness. Finally, we provide ThisJava, a prototype implementation of the calculus, to show its backward compatibility, and we make it publicly available. We believe that our approach theoretically expands the long pursuit of an object-oriented language with ThisTypes to support more useful methods with more precise types.","ThisType, binary methods, generic factory methods, exact types, virtual constructors, Object-oriented languages",,ThisJava,
"Na H,Ryu S,Choe K",Exact Type Parameterization and ThisType Support,"We propose language support for binary methods and generic factory methods using ThisType. We present three new language features: (1) exact type capture which relaxes the restriction of earlier static approaches to binary methods that the run-time type of a binary method's receiver should be statically fixed, (2) named wildcards which allow more binary method invocations and more precise typing results, and (3) virtual constructors which support method definitions with return types of ThisType. We formalize these features with a core calculus CoreThisJava and prove its type soundness, exact type match and algorithmic subtyping.A modified notion of ThisType and exact type parameterization with bidirectional F-bound property form the basis of the above features. We also show that \inheritance makes subtypes\"" with our notion of ThisType and existential types as object types.""","generic factory methods, exact types, exact type capture, binary methods, virtual constructors, object-oriented languages, thistype, named wildcards",,ThisJava,
H. M. Al-Haddad; K. M. George; M. H. Samadzadeh,Description of a new approach to object inheritance,"A new approach to object inheritance is proposed. The approach is a two-faceted object inheritance model (TIM). TIM is compared with the existing models in terms of the inheritance features provided by these models. TIM is an object inheritance model based on code sharing with the ability to capture the other views of inheritance. It provides single and multiple inheritance on the basis of the message-passing paradigm and provides semantics for object creation and deletion. TIM avoids some of the problems in the existing models and provides full support for other issues related to object-oriented programming such as information hiding, subtyping, and the visibility of inheritance. A simulation of a C++ program using TIM is given as an example.<<ETX>></ETX>",,TIM,TIM Model,
"Cameron N,Noble J,Wrigstad T",Tribal Ownership,"Tribal Ownership unifies class nesting and object ownership. Tribal Ownership is based on Tribe, a language with nested classes and object families. In Tribal Ownership, a program's runtime object ownership structure is characterised by the lexical nesting structure of its classes.We build on a variant of Tribe to present a descriptive ownership system, using object nesting to describe heap partitions, but without imposing any restrictions on programming disciplines. We then demonstrate how a range of different prescriptive ownership policies can be supported on top of the descriptive Tribal Ownership mechanism; including a novel owners-as-local-dominators policy. We formalise our type system and prove soundness and several ownership invariants. The resulting system requires strikingly few annotations, and uses well-understood encapsulation techniques to create ownership systems that should be intuitive for programmers.","family polymorphism, virtual classes, nested classes, ownership types",,Tribe,
"Chandersekaran CS,Linger RC",Software specification using the special language,"This paper presents a tutorial overview of special, a formal specification and assertion language created by SRI International as part of their hierarchical design methodology. The language is based on a formal model of system behavior and is supported by language processors that assist in the interactive development of specifications. special is a strongly typed language that models data and programs as abstract resources known as objects. Collections of modules known as abstract machines are the major building blocks of a software specification in special. The technical foundations of special and the components of a special specification are described. A sample specification is detailed in an appendix.",,abstract machines,turing machines,
"Maidl AM,Mascarenhas F,Ierusalimschy R",A Formalization of Typed Lua,"Programmers often migrate from a dynamically typed to a statically typed language when their simple scripts evolve into complex programs. Optional type systems are one way of having both static and dynamic typing in the same language, while keeping its dynamically typed semantics. This makes evolving a program from dynamic to static typing a matter of describing the implied types that it is using and adding annotations to make those types explicit. Designing an optional type system for an existing dynamically typed language is challenging, as its types should feel natural to programmers that are already familiar with this language. In this work, we give a formal description of Typed Lua, an optional type system for Lua, with a focus on two of its novel type system features: incremental evolution of imperative record and object types that is both lightweight and type-safe, and projection types, a combination of flow typing, functions that return multiple values, and multiple assignment. While our type system is tailored to the features and idioms of Lua, its features can be adapted to other imperative scripting languages.","Lua, Gradual Typing, Optional Type Systems",,TypedLua,
Kurz A,Specifying Coalgebras with Modal Logic,"We propose to use modal logic as a logic for coalgebras and discuss it in view of the work done on coalgebras as a semantics of object-oriented programming. Two approaches are taken: First, standard concepts of modal logic are applied to coalgebras. For a certain kind of functor it is shown that the logic exactly captures the notion of bisimulation and a complete calculus is given. Second, we discuss the relationship of this approach with the coalgebraic logic of Moss [6].",,,UML,
"Ishikawa Y,Tomura S,Futatsugi K",The Semantics of an Object-Oriented Concurrent Programming Language: Process Algebraic Approach,"Summary In this paper, the formal semantics of an object-oriented concurrent programming language called Mono is given. Mono is a model language that includes key features of object-oriented concurrent languages, e.g., synchronous and asynchronous message passing, delegation mechanism, and so on. A process algebra called ECCS, which is an extension of CCS, is introduced. The semantics of ECCS is defined by inference rules. The transformation function that transforms Mono into ECCS gives the formal semantics of Mono.",,,UML,
"Rees DL,Stephenson K,Tucker JV",The algebraic structure of interfaces,"In this paper we examine formally the idea that the architecture of a system can be modelled by the structure of its interface expressed in terms of the interfaces for its components. Thus,SystemInterfaceArchitecture=StructuredsetofSub-systemInterfaces.We specify an abstract model for interface definition languages (IDLs) based on this idea and the idea that anInterface=Name+Imports+Body.A set of interfaces is a repository. An interface architecture is a repository with some primary interfaces identified; the import dependencies between the interfaces of a repository are used to determine its structure. The abstract model uses algebraic specifications to define the abstract syntax of a general IDL, and interface transformations using structural induction. We examine a flattening process which assembles a system interface from its components. We use the general model to derive a simple IDL suitable for the design phase of object-oriented software development. This requires us to specify a form of Body that treats both data types and state, and in Body we explicitly distinguish between methods with and without side-effects, by commands and queries, respectively. We also consider alternative proposals for Body that yield new IDLs, including other object-oriented design languages and data type specification languages.","Interface, Interface definition language, Imports, Flattening, Software architecture, Algebraic specification, Abstract syntax, Object-oriented architecture",,UML,
"Bergel A,Ducasse S,Nierstrasz O,Wuyts R",Stateful traits and their formalization,"Traits offer a fine-grained mechanism to compose classes from reusable components while avoiding problems of fragility brought by multiple inheritance and mixins. Traits as originally proposed are stateless, that is, they contain only methods, but no instance variables. State can only be accessed within stateless traits by accessors, which become required methods of the trait. Although this approach works reasonably well in practice, it means that many traits, viewed as software components, are artificially incomplete, and classes that use such traits may contain significant amounts of boilerplate glue code. We present an approach to stateful traits that is faithful to the guiding principle of stateless traits: the client retains control of the composition. Stateful traits consist of a minimal extension to stateless traits in which instance variables are purely local to the scope of a trait, unless they are explicitly made accessible by the composing client of a trait. We demonstrate by means of a formal object calculus that adding state to traits preserves the flattening property: traits contained in a program can be compiled away. We discuss and compare two implementation strategies, and briefly present a case study in which stateful traits have been used to refactor the trait-based version of the Smalltalk collection hierarchy.","Traits, Mixin, Multiple-inheritance, Eiffel, Jigsaw, Flattening",,VDM,
"Abadi M,Cardelli L",A theory of primitive objects: Second-order systems,"We describe a second-order calculus of objects. The calculus supports object subsumption, method override, and the type Self. It is constructed as an extension of System F with subtyping, recursion, and first-order object types.",,,VDM,
A. Nadeem; M. R. Lyu,A Framework for Inheritance Testing from VDM++ Specifications,"The benefits offered by the use of formal methods are not limited to avoidance of specification errors and elimination of ambiguities only - a formal specification also provides a sound basis for generating test suites. Inheritance is a powerful mechanism in object-oriented paradigm by which a subclass inherits data and functionality of a super class. Testing of inheritance relationships is crucial in object-oriented testing, as an inheritance error may lead to subtle bugs such as due to overridden functionality. In this paper, we introduce a technique to generate test cases for inheritance testing, using a VDM++ formal specification. The proposed technique is based on the flattening of a VDM++ specification class, and then generating operation sequences from the trace structure specified in the VDM++ specification. The input space for each operation is partitioned, and a test model is constructed from the operation sequences and the input partitions. Test paths are generated from the test model, which cover the different operation sequences as well as the partitions. We also define various coverage criteria for test path generation",,,VDM,
R. Vosilovich kabulov; O. Bakhtiyorovich Ruzibaev; K. Temur Ataxanovich; S. Saidqulovich Muminov,Formalization of Data Derivative Structures,"The paper considers the topical issue of formal description of data structures. Data structures are widely used in modern object-oriented programming to solve various practical problems. The paper introduces functions for performing operations with such data structures as stack, queue, and priority queue. The conditions that these functions must satisfy are introduced as axioms. To describe the axioms, an approach based on an abstract data type, algebraic and programmatic approaches were used.",data structure;container;type;function;axiom;precondition;constructor;operation,,Vosilovich model,data model
Wand M,Type inference for record concatenation and multiple inheritance,"We show that the type inference problem for a lambda calculus with records, including a record concatenation operator, is decidable. We show that this calculus does not have principal types, but does have finite complete sets of types: that is, for any term M in the calculus, there exists an effectively generable finite set of type schemes such that every typing for M is an instance of one of the schemes in the set. We show how a simple model of object-oriented programming, including hidden instance variables and multiple inheritance, may be coded in this calculus. We conclude that type inference is decidable for object-oriented programs, even with multiple inheritance and classes as first-class values.",,,Wand's model,
"Mackay J,Potanin A,Aldrich J,Groves L",Decidable Subtyping for Path Dependent Types,"Path dependent types have long served as an expressive component of the Scala programming language. They allow for the modelling of both bounded polymorphism and a degree of nominal subtyping. Nominality in turn provides the ability to capture first class modules. Thus a single language feature gives rise to a rich array of expressiveness. Recent work has proven path dependent types sound in the presence of both intersection and recursive types, but unfortunately typing remains undecidable, posing problems for programmers who rely on the results of type checkers. The Wyvern programming language is an object oriented language with path dependent types, recursive types and first class modules. In this paper we define two variants of Wyvern that feature decidable typing, along with machine checked proofs of decidability. Despite the restrictions, our approaches retain the ability to encode the parameteric polymorphism of Java generics along with many idioms of the Scala module system.","Subtyping, Object Oriented Languages, Structural Subtyping, Functional Languages, Nominal Subtyping, Wyvern, Scala, Decidability, Language Design, Path Dependent Types",,"Wyvern
PL",
"Nistor L,Kurilova D,Balzer S,Chung B,Potanin A,Aldrich J","Wyvern: A Simple, Typed, and Pure Object-Oriented Language","The simplest and purest practical object-oriented language designs today are seen in dynamically-typed languages, such as Smalltalk and Self. Static types, however, have potential benefits for productivity, security, and reasoning about programs. In this paper, we describe the design of Wyvern, a statically typed, pure object-oriented language that attempts to retain much of the simplicity and expressiveness of these iconic designs.Our goals lead us to combine pure object-oriented and functional abstractions in a simple, typed setting. We present a foundational object-based language that we believe to be as close as one can get to simple typed lambda calculus while keeping object-orientation. We show how this foundational language can be translated to the typed lambda calculus via standard encodings. We then define a simple extension to this language that introduces classes and show that classes are no more than sugar for the foundational object-based language. Our future intention is to demonstrate that modules and other object-oriented features can be added to our language as not more than such syntactical extensions while keeping the object-oriented core as pure as possible.The design of Wyvern closely follows both historical and modern ideas about the essence of object-orientation, suggesting a new way to think about a minimal, practical, typed core language for objects.","first-class classes, object-oriented, static type checking",,Wywern,
M. A. El-Zawawy,A Robust Framework for Asynchronous Operations on a Functional Object-Oriented Model,"Functional programming is a technique for expressing the constructions and constructs of computer software. This technique treats calculations similarly to the calculation functions in mathematics. Therefore concepts of semantic- states and changeable data are avoided. It may be defined as a declarative technique of programming meaning that programs are mainly expressions. An efficient programming style for systems is asynchronous programming which manages communications with system environment. Asynchronous programming is based on the idea of non-blocking execution of commands and keeping list of tasks in buffers for latter executions. The alternative style to asynchronous programming is to wait for the completion of long commands which leads to programs-execution problems. This paper introduces a robust framework for asynchronous operations on a functional object-oriented model for programming. Up to our knowledge, this is the first technique of its type. The presented model includes syntax for the language constructs and their (operational) semantics. The semantics is meant to serve as a formal background for the construction of theoretical analyses for the presented programming model. The paper presents also a programming example for the proposed model.",,,Zawawy model,
"Greiner S,Brest J,Žumer V",Zero—a blend of static typing and dynamic metaprogramming,"Zero is an experimental statically typed, fully object-oriented reflective programming language. Reflective features cover introspection as well as structural and behavioural reflection. The reflective facilities include safe method and class replacements and detailed modification of methods. These enable Zero programs to quickly accommodate to run-time requirements. Behavioural reflection is realised using handlers (hooks), which may be attached to all language constructs based on closures. Zero provides an efficient static typing system with run-time extensions. Methods are first class values and are represented as objects when such representation is required. By using such representation, Zero provides elegant use of statically typed higher-order methods.","Language design, Object-oriented programming, Structural reflection, Behavioural reflection, Static typing, Run-time modification",,"Zero
PL",
Zhao T,Polymorphic Type Inference for Scripting Languages with Object Extensions,This paper presents a polymorphic type inference algorithm for a small subset of JavaScript. The goal is to prevent accessing undefined members of objects. We define a type system that allows explicit extension of objects through add operation and implicit extension through method calls. The type system also permits strong updates and unrestricted extensions to new objects. The type inference algorithm is modular so that each function definition is only analyzed once and larger programs can be checked incrementally.,"type inference, javascript, dynamic languages, static types",,Zhao type system,
"Yang Q,Xu MW,Pi C",Delegation: A Language Facility for Dynamic Software Adaptation,"Due to the growing complexity of computing systems, and the increasing demand for high availability and reliability of them, adapting software at runtime is becoming more and more important. However, there is not sufficient support for dynamic software adaptation at the level of programming languages. In this paper, we investigate a language feature, namely delegation, to argue that delegation is a favorite choice to deal with dynamic software adaptation. To do that, we present Φ calculus, which is an imperative object-based calculus with delegation, to model essential features of languages, with focusing on how to incorporate delegation into programming languages to support dynamic software adaptation. We give the operational semantics of Φ calculus. We also state how delegation is used in object extending and method sharing between objects. We conclude that delegation makes dynamic software adaptation simpler and more flexible.","Φ object calculus, delegate, object calculus, delegation, dynamic software adaptation",,Φ calculus,
S. Alagić,Temporal Object-Oriented Programming,"An object-oriented, declarative, statically typed and temporal language system is presented. What makes this system very different from the currently prevailing strongly typed procedural object-oriented language systems is that methods are specified in a high-level, constraint sublanguage. The constraint sublanguage is based on a particular temporal paradigm, which has an execution model as well as the formal, initial model semantics. This constraint language system is seen as a non-traditional component of a sophisticated, typed object-oriented programming environment. It complements the procedural object-oriented languages in the areas of prototyping, simulation and databases. The paper covers the core ideas, the programming methodology, the type system, and the implementation techniques. Possible concurrent extensions and the limitations of the system are also discussed.",,,,no source
Zhang Qian; Li Weihua; Chen Shihong,The Concurrent Objects Calculus,"Research in concurrent object-oriented programming languages has suffered from the lack of a widely accepted formal foundation for describing the semantics of concurrent object systems. Based on the /spl pi/-calculus and the actor model respectively, people have tried to define a common semantic framework for concurrent object-oriented programming. In this paper, we try to compromise these two approaches. We define a formalism that enjoys a clean formal definition which allows the reuse of standard results of the theory of concurrency while preserving a high-level object-oriented programming style. We propose an actor algebra and a concurrent object calculus, and then we give the translation relationship between the two.",,,,no source
A. Borgida; J. Mylopoulos; R. Reiter,On the frame problem in procedure specifications,"The paper provides examples of situations where formal specifications of procedures in the standard pre/postcondition style become lengthy, cumbersome and difficult to change, a problem which is particularly acute in the case of object oriented specifications with inheritance. We identify the problem as the inability to express that a procedure changes only those things it has to, leaving everything else unmodified, and review some attempts at dealing with this ""frame problem"" in the software specification community. The second part of the paper adapts a recent proposal for a solution to the frame problem in artificial intelligence-the notion of explanation closure axioms-to provide an approach whereby one can state such conditions succinctly and modularly, with the added advantage of having the specifier be reminded of things that she may have omitted saying in procedure specifications. Since this approach is based on standard predicate logic, its semantics are relatively straightforward. The paper also suggests an algorithm which generates syntactically the explanation closure axioms from the pre/postcondition specifications, provided they are written in a restricted language; it also suggests a model theory supporting it.<<ETX>></ETX>",Borgida model of frame problem,,,not a full model
S. Subramanian; J. V. Cook,Automatic verification of object code against source code,"An important step when applying formal methods to gain assurance of trusted systems is the verification of object code against source code. One way to mechanically verify that the object code faithfully implements the source code from which it is compiled is to verify the compiler. However, verifying the implementation of an industrial-strength compiler is a very difficult technical problem at the present time. For small fragments of code, it may be easier to verify the equivalence of the source and object code by reasoning about their behavior directly without dealing with the algorithm used for translation. In this paper, we describe a system for automatically verifying MC68020 object code against C source code. The semantics of a small subset of C and MC68020 object code are formalized in the logic of Nqthm (a.k.a. the Boyer-Moore theorem prover). After a large collection of lemmas about C and MC68020 semantics are made available, Nqthm is able to prove the correctness theorems automatically for a small class of programs. For practical use of the system to be possible, we wrote a front-end to Nqthm that generates correctness theorems, given the C source file as input. Using our front-end, we tested our system by verifying the object code produced by the GCC and CC compilers for some small programs.",,,,